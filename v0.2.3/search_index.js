var documenterSearchIndex = {"docs":
[{"location":"library/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"library/","page":"Reference","title":"Reference","text":"The following reproduces the in-lined documentation about types and methods of the QuickHeaps package. This documentation is also available from the REPL by typing ? followed by the name of a method or a type.","category":"page"},{"location":"library/#Binary-Heaps","page":"Reference","title":"Binary Heaps","text":"","category":"section"},{"location":"library/","page":"Reference","title":"Reference","text":"QuickHeaps.AbstractBinaryHeap\nQuickHeaps.BinaryHeap\nQuickHeaps.FastBinaryHeap\nQuickHeaps.heapify\nQuickHeaps.heapify!\nQuickHeaps.heapify_down!\nQuickHeaps.heapify_up!\nQuickHeaps.isheap\nQuickHeaps.unsafe_heapify_down!\nQuickHeaps.unsafe_heapify_up!\nQuickHeaps.unsafe_grow!\nQuickHeaps.unsafe_shrink!","category":"page"},{"location":"library/#QuickHeaps.AbstractBinaryHeap","page":"Reference","title":"QuickHeaps.AbstractBinaryHeap","text":"QuickHeaps.AbstractBinaryHeap{T,O}\n\nis the super-type of binary heaps in QuickHeaps whose values have type T and whose ordering has type O.\n\nThe following methods are available for a binary heap h (those which modify the heap contents re-order heap values as needed to maintain the heap structure):\n\npop!(h)        # deletes and returns root value of heap h\npush!(h, x)    # pushes value x in heap h\nempty!(h)      # empties heap h\nisempty(h)     # yields whether heap h is empty\ndelete!(h, i)  # deletes i-th value from heap h\npeek(h)        # yields root value of heap h without deleting it\nfirst(h)       # idem\nsetroot!(h, x) # same as h[1] = x, replaces root value of heap h by x\n\nA binary heap h behaves like an abstract vector (with 1-based linear indices), in particular:\n\nlength(h)   # the number of values in heap h\nh[i]        # the i-th value of heap h\nh[i] = x    # set the i-th value of heap h and heapify h\n\nNote that h[1] is the root value of the heap h and that setting a value in the heap may trigger reordering of the values to maintain the binary heap structure. In other words, after doing h[i] = x, do not assume that h[i] yields x.\n\nOperations that modify the heap, like deletion by delete!(h,i), insertion by h[i] = x, pushing by push!(h,x), and extracting by pop!(h) are of complexity O(1) in the best case, O(log(n)) in the worst case, with n = length(h) the number of values in the heap h. Retrieving a given value with peek(h), first(h), or h[i] is always of complexity O(1).\n\n\n\n\n\n","category":"type"},{"location":"library/#QuickHeaps.BinaryHeap","page":"Reference","title":"QuickHeaps.BinaryHeap","text":"BinaryHeap{T}([o::Ordering = Forward,][ vals::AbstractVector])\n\nyields an empty binary heap whose values have type T and with ordering specified by o. For example, a min-heap (resp. a max-heap) is built if o specifies forward (resp. reverse) ordering.\n\nAn optional vector vals storing the initial values of the binary heap can be specified. These values in vals need not be ordered, the BinaryHeap constructor automatically takes care of that. If vals is a Vector{T} instance, the binary-heap will be directly built into vals. Call BinaryHeap(copy(vals)) to create a binary heap with its own storage.\n\nArguments o and vals may be specified in any order.\n\nMethod sizehint!(h,n) may be called to anticipate that the heap may contains n values.\n\n\n\n\n\n","category":"type"},{"location":"library/#QuickHeaps.FastBinaryHeap","page":"Reference","title":"QuickHeaps.FastBinaryHeap","text":"FastBinaryHeap{T}([o::Ordering = FastForward,][ vals::AbstractVector])\n\nyields a fast binary heap. Compared to BinaryHeap{T}(...), the default ordering is FastForward and the array backing the storage of the heap values is never reduced to improve performances in some cases. You may call resize!(h) to explicitly reduce the storage of fast binary-heap h to its minimum.\n\n\n\n\n\n","category":"type"},{"location":"library/#QuickHeaps.heapify","page":"Reference","title":"QuickHeaps.heapify","text":"heapify([o=Base.Forward,] A, n=length(A))\n\nyields an array with the n first values of array A stored in a binary heap structure of ordering specified by o. The storage of the returned heap is a different array than A. Arguments may be specified in any order.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.heapify!","page":"Reference","title":"QuickHeaps.heapify!","text":"heapify!(h) -> h\n\nreorders the values in the binary heap h in-place. This method should be called to initialize the heap or to re-order the heap if its contents have been modified by other methods than pop! or push!.\n\nThe method can be called at a lower level to heapify (part of) an array storing the heap values:\n\nheapify!([o=Base.Forward,] A, n=length(A)) -> A\n\nreorders the n first elements of array A in-place to form a binary heap according to the ordering specified by o. The array A must have 1-based linear indexing. Arguments may be specified in any order.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.heapify_down!","page":"Reference","title":"QuickHeaps.heapify_down!","text":"QuickHeaps.heapify_down!(o, A, i, x=A[i], n=lengh(A)) -> A\n\nstores the value x in the i-th entry of the binary heap built into the n first elements of array A with ordering o and, if needed, moves down the inserted value to maintain the binary heap structure.\n\nThis method is called to heapify an array in order to initialize or rebuild the heap structure or to replace the value of the root value of the heap and update the heap structure.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.heapify_up!","page":"Reference","title":"QuickHeaps.heapify_up!","text":"QuickHeaps.heapify_up!(o, A, i, x=A[i]) -> A\n\nstores the value x in the i-th entry of the binary heap built into the i first elements of array A with ordering o and, if needed, moves up the value to maintain the heap structure.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.isheap","page":"Reference","title":"QuickHeaps.isheap","text":"isheap([o=Base.Forward,], A, n=length(A))\n\nyields whether the n first elements of array A have a binary heap structure ordered as specified by o. Arguments may be specified in any order.\n\nisheap(obj; check=false)\n\nyields whether object obj is a binary heap. If keyword check is true, the internal structure of obj is checked; otherwise, the type of obj is trusted to determine whether it is a binary heap.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.unsafe_heapify_down!","page":"Reference","title":"QuickHeaps.unsafe_heapify_down!","text":"QuickHeaps.unsafe_heapify_down!(o, A, i, x=A[i], n=lengh(A))\n\nThis method is a fast but unsafe version of QuickHeaps.heapify_down! which assumes that all arguments are correct, that is A implements 1-based linear indexing, 0 ≤ n ≤ lengh(A), and 1 ≤ i ≤ n.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.unsafe_heapify_up!","page":"Reference","title":"QuickHeaps.unsafe_heapify_up!","text":"QuickHeaps.unsafe_heapify_up!(o, A, i, x=A[i])\n\nThis methods is a fast but unsafe version of QuickHeaps.heapify_up! which assumes that all arguments are correct, that is A implements 1-based linear indexing and 1 ≤ i ≤ length(A).\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.unsafe_grow!","page":"Reference","title":"QuickHeaps.unsafe_grow!","text":"QuickHeaps.unsafe_grow!(h, n) -> A\n\ngrows the size of the binary heap h to be n and returns the array A backing the storage of the values. This method is unsafe because it does not check its arguments and because it breaks the binary heap structure of the array of values.\n\nThis method is called by push! to grow the size of the heap and shall be specialized for any concrete sub-types of QuickHeaps.AbstractBinaryHeap.\n\n\n\n\n\nQuickHeaps.unsafe_grow!(pq, n) -> pq\n\ngrows the size of the binary heap backing the storage of the nodes of the priority queue pq to be n and returns the priority queue object.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.unsafe_shrink!","page":"Reference","title":"QuickHeaps.unsafe_shrink!","text":"QuickHeaps.unsafe_shrink!(h, n)\n\nshrinks the size of the binary heap h to be n. This method is unsafe because it does not check its arguments.\n\nThis method is called by delete! to eventually reduce the size of the heap and shall be specialized for any concrete sub-type of QuickHeaps.AbstractBinaryHeap.\n\n\n\n\n\nQuickHeaps.unsafe_shrink!(pq, n)\n\nshrinks the size of the binary heap backing the storage of the nodes of the priority queue pq to be n.\n\n\n\n\n\n","category":"function"},{"location":"library/#Priority-Queues","page":"Reference","title":"Priority Queues","text":"","category":"section"},{"location":"library/","page":"Reference","title":"Reference","text":"QuickHeaps.AbstractPriorityQueue\nQuickHeaps.PriorityQueue\nQuickHeaps.FastPriorityQueue\ndequeue!(::QuickHeaps.AbstractPriorityQueue)\ndequeue_node!\ndequeue_pair!","category":"page"},{"location":"library/#QuickHeaps.AbstractPriorityQueue","page":"Reference","title":"QuickHeaps.AbstractPriorityQueue","text":"QuickHeaps.AbstractPriorityQueue{K,V,O}\n\nis the super type of priority queues with nodes consisting in pairs of keys of type K, priority values of type V, and ordering of type O<:Base.Ordering.\n\nPriority queues implement an API similar to dictionaries with the additional feature of maintaining an ordered structure so that getting the node of highest priority costs O(1) while pushing a node costs O(log(n)) with n the size of the queue. See online documentation for more details.\n\nQuickHeaps provides two concrete types of priority queues: PriorityQueue for any kind of keys and FastPriorityQueue for keys which are analoguous to array indices.\n\n\n\n\n\n","category":"type"},{"location":"library/#QuickHeaps.PriorityQueue","page":"Reference","title":"QuickHeaps.PriorityQueue","text":"PriorityQueue{K,V}([o=Forward,] T=Node{K,V})\n\nyields a priority queue for keys of type K and priority values of type V. Optional arguments o::Ordering and T<:AbstractNode{K,V} are to specify the ordering of values and type of nodes to store key-value pairs. Type parameters K and V may be omitted if the node type T is specified.\n\nHaving a specific node type may be useful to specialize the Base.lt method which is called to determine the order.\n\nIf keys are analoguous to array indices (linear or Cartesian), FastPriorityQueue may provide a faster alternative.\n\n\n\n\n\n","category":"type"},{"location":"library/#QuickHeaps.FastPriorityQueue","page":"Reference","title":"QuickHeaps.FastPriorityQueue","text":"FastPriorityQueue{V}([o=Forward,] [T=Node{Int,V},] dims...)\n\nyields a priority queue for keys analoguous of indices in an array of size dims... and priority values of type V. Optional arguments o::Ordering and T<:AbstractNode{Int,V} are to specify the ordering of values and type of nodes to store key-value pairs (the key is stored as a linear index of type Int). Type parameter V may be omitted if the node type T is specified.\n\nSee PriorityQueue if keys cannot be assumed to be array indices.\n\n\n\n\n\n","category":"type"},{"location":"library/#DataStructures.dequeue!-Tuple{AbstractPriorityQueue}","page":"Reference","title":"DataStructures.dequeue!","text":"dequeue!(pq) -> key\n\nremoves the root node from the priority queue pq and returns its key.\n\nAlso see dequeue_node! and dequeue_pair!.\n\n\n\n\n\n","category":"method"},{"location":"library/#QuickHeaps.dequeue_node!","page":"Reference","title":"QuickHeaps.dequeue_node!","text":"dequeue_node!(pq) -> node\n\nremoves and returns the root node from the priority queue pq.\n\nAlso see dequeue! and dequeue_pair!.\n\n\n\n\n\n","category":"function"},{"location":"library/#DataStructures.dequeue_pair!","page":"Reference","title":"DataStructures.dequeue_pair!","text":"dequeue_pair!(pq) -> (key => val)\n\nremoves the root node from the priority queue pq and returns it as a key-value Pair. This is the same as pop!(pq).\n\nAlso see dequeue! and dequeue_node!.\n\n\n\n\n\n","category":"function"},{"location":"library/#Nodes","page":"Reference","title":"Nodes","text":"","category":"section"},{"location":"library/","page":"Reference","title":"Reference","text":"QuickHeaps.AbstractNode\nQuickHeaps.Node\nQuickHeaps.get_key\nQuickHeaps.get_val","category":"page"},{"location":"library/#QuickHeaps.AbstractNode","page":"Reference","title":"QuickHeaps.AbstractNode","text":"QuickHeaps.AbstractNode{K,V}\n\nis the super-type of nodes with a key of type K and a value of type V. Nodes can be used in binary heaps and priority queues to represent key-value pairs and specific ordering rules may be imposed by specializing the Base.lt method which is by default:\n\nBase.lt(o::Ordering, a::T, b::T) where {T<:QuickHeaps.AbstractNode} =\n    lt(o, QuickHeaps.get_val(a), QuickHeaps.get_val(b))\n\n\n\n\n\n","category":"type"},{"location":"library/#QuickHeaps.Node","page":"Reference","title":"QuickHeaps.Node","text":"QuickHeaps.Node{K=typeof(k),V=typeof(v)}(k,v)\n\nyields a node storing key k and value v. Optional type parameters K and V are the respective types of the key and of the value.\n\nSee also QuickHeaps.AbstractNode, QuickHeaps.AbstractPriorityQueue.\n\n\n\n\n\n","category":"type"},{"location":"library/#QuickHeaps.get_key","page":"Reference","title":"QuickHeaps.get_key","text":"get_key(x::QuickHeaps.AbstractNode) -> k\n\nyields the key k of node x. This method may be specialized for any sub-types of QuickHeaps.AbstractNode.\n\nAlso see QuickHeaps.get_val.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.get_val","page":"Reference","title":"QuickHeaps.get_val","text":"QuickHeaps.get_val(x::QuickHeaps.AbstractNode) -> v\n\nyields the value v of node x. This method may be specialized for any sub-types of QuickHeaps.AbstractNode.\n\nAlso see QuickHeaps.get_key.\n\n\n\n\n\n","category":"function"},{"location":"library/#Orderings","page":"Reference","title":"Orderings","text":"","category":"section"},{"location":"library/","page":"Reference","title":"Reference","text":"QuickHeaps.FastForwardOrdering\nQuickHeaps.default_ordering","category":"page"},{"location":"library/#QuickHeaps.FastForwardOrdering","page":"Reference","title":"QuickHeaps.FastForwardOrdering","text":"FastForwardOrdering\n\nis the singleton type for fast forward ordering without considering NaN's.\n\n\n\n\n\n","category":"type"},{"location":"library/#QuickHeaps.default_ordering","page":"Reference","title":"QuickHeaps.default_ordering","text":"default_ordering(T)\n\nyields the default ordering for an ordered data structure of type T.  This method shall be specialized for each ordered data structure.\n\n\n\n\n\n","category":"function"},{"location":"library/#Miscellaneous","page":"Reference","title":"Miscellaneous","text":"","category":"section"},{"location":"library/","page":"Reference","title":"Reference","text":"The following unexported methods may be needed for implementing new types of binary heap or of priority queue. End-users probably not have to worry about these.","category":"page"},{"location":"library/","page":"Reference","title":"Reference","text":"QuickHeaps.has_bad_values\nQuickHeaps.has_standard_linear_indexing\nQuickHeaps.heap_index\nQuickHeaps.in_range\nQuickHeaps.is_one_based_unit_range\nQuickHeaps.linear_index\nQuickHeaps.nodes\nQuickHeaps.index\nQuickHeaps.storage\nQuickHeaps.ordering\nQuickHeaps.setroot!\nQuickHeaps.to_eltype\nQuickHeaps.to_key\nQuickHeaps.to_node\nQuickHeaps.to_val\nQuickHeaps.typename","category":"page"},{"location":"library/#QuickHeaps.has_bad_values","page":"Reference","title":"QuickHeaps.has_bad_values","text":"has_bad_values(A[, isbad])\n\nyields whether array A has bad values according to predicate isbad. For arrays with floating-point values, isbad default to isnan if unspecified. For integer-valued arrays, this function always returns false if isnan is unspecified.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.has_standard_linear_indexing","page":"Reference","title":"QuickHeaps.has_standard_linear_indexing","text":"has_standard_linear_indexing(A)\n\nyields whether array A implements standard linear indexing (1-based).\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.heap_index","page":"Reference","title":"QuickHeaps.heap_index","text":"Quickheaps.heap_index(pq, k) -> i\n\nyields the index of the key k in the binary heap backing the storage of the nodes of the priority queue pq. If the key is not in priority queue, i = 0 is returned, otherwise i ∈ 1:n with n = length(pq) is returned.\n\nThe heap_index method is used to implement haskey, get, and delete! methods for priority queues.  The heap_index method shall be specialized for any concrete sub-types of QuickHeaps.AbstractPriorityQueue.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.in_range","page":"Reference","title":"QuickHeaps.in_range","text":"in_range(i, len::Integer)\n\nyields whether 1 ≤ i ≤ len.\n\nin_range(i, A::Array)\n\nyields whether i is a valid linear index of array A.\n\nin_range(i, R::AbstractUnitRange{<:Integer})\n\nyields whether i is in the range R.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.is_one_based_unit_range","page":"Reference","title":"QuickHeaps.is_one_based_unit_range","text":"is_one_based_unit_range(itr)\n\nyields whether iterator itr is a 1-based unit range.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.linear_index","page":"Reference","title":"QuickHeaps.linear_index","text":"QuickHeaps.linear_index(pq, k)\n\nconverts key k into a linear index suitable for the fast priority queue pq. The key can be a linear index or a multi-dimensional index (anything accepted by to_indices).  The current settings for bounds checking are used.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.nodes","page":"Reference","title":"QuickHeaps.nodes","text":"QuickHeaps.nodes(pq)\n\nyields the array backing the storage of the nodes of priority queue pq.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.index","page":"Reference","title":"QuickHeaps.index","text":"QuickHeaps.index(pq) -> I\n\nyields the object I storing the key-index association in priority queue pq. This object can be used as I[key] to yield , for a given key, the index in QuickHeaps.nodes(pq), the associated binary heap.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.storage","page":"Reference","title":"QuickHeaps.storage","text":"QuickHeaps.storage(h)\n\nyields the array backing the storage of the values in the binary heap h.\n\nThis method may be specialized for custom binary heap types.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.ordering","page":"Reference","title":"QuickHeaps.ordering","text":"QuickHeaps.ordering(h)\n\nyields the ordering of the values in the binary heap h.\n\nThis method may be specialized for custom binary heap types.\n\n\n\n\n\nQuickHeaps.ordering(pq) -> o\n\nyields the object o specifying the ordering of priority values in the priority queue pq.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.setroot!","page":"Reference","title":"QuickHeaps.setroot!","text":"setroot!(h, x) -> h\n\nreplaces the value of the root note in heap h by x. This is similar to h[1] = x but a bit faster.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.to_key","page":"Reference","title":"QuickHeaps.to_key","text":"Quickheaps.to_key(pq, k)\n\nconverts the key k to the type suitable for priority queue pq.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.to_node","page":"Reference","title":"QuickHeaps.to_node","text":"Quickheaps.to_node(pq, k, v)\n\nconverts the the key k and the value v into a node type suitable for priority queue pq.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.to_val","page":"Reference","title":"QuickHeaps.to_val","text":"Quickheaps.to_val(pq, v)\n\nconverts the value v to the type suitable for priority queue pq.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.typename","page":"Reference","title":"QuickHeaps.typename","text":"typename(x)\n\nyields a short string describing the type of object x.  Argument may also be the object type.\n\n\n\n\n\n","category":"function"},{"location":"priorityqueues/#Priority-queues","page":"Priority queues","title":"Priority queues","text":"","category":"section"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"Priority queues are partially ordered dynamic lists of so-called nodes which are key-value pairs. Priority queues are designed so that updating the list of stored nodes while maintaining the ordering and retrieving or extracting the node of highest priority are efficient operations.","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"Priority queues provided by QuikHeaps are similar to dictionaries (or to arrays) with the additional feature of maintaining an ordered structure so that getting the node of highest priority costs O(1) operations while changing the priority of a node or pushing a node only costs O(log(n)) operations with n the length of the queue.","category":"page"},{"location":"priorityqueues/#Building-priority-queues","page":"Priority queues","title":"Building priority queues","text":"","category":"section"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"In QuikHeaps, priority queues combine a binary heap to store the partially sorted list of nodes and another structure to associate keys and nodes. There are two possibilities depending on the kind of keys.","category":"page"},{"location":"priorityqueues/#Versatile-priority-queues","page":"Priority queues","title":"Versatile priority queues","text":"","category":"section"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"QuikHeaps provides versatile priority queues which use a dictionary to associate keys with nodes and thus impose no restrictions on the type of the keys. To build a versatile priority queue, call the PriorityQueue constructor:","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"Q = PriorityQueue{K,V}([o=Forward,] T=Node{K,V})","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"where optional parameter o::Ordering specifies the ordering for deciding the priority of values while optional parameter T<:AbstractNode{K,V} specifies the type of the nodes with K and V the respective types of the keys and of the values. Type parameters K and V may be omitted if the node type T is specified.","category":"page"},{"location":"priorityqueues/#Fast-priority-queues","page":"Priority queues","title":"Fast priority queues","text":"","category":"section"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"If keys are analoguous to indices in some array, the key-node association can be realized by a regular array which is faster than a dictionary as used by versatile priority queues. To build a fast priority queue with keys indexing an array of dimensions dims..., call the FastPriorityQueue constructor:","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"Q = FastPriorityQueue{V}([o=Forward,] [T=Node{Int,V},] dims...)","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"where o::Ordering specifies the ordering of values in the priority queue, T<:AbstractNode{Int,V} is the type of the nodes depending on V the type of the values encoding the priority. Type parameter V may be omitted if the node type T is specified.","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"The keys in this kind of priority queue are the linear or Cartesian indices in an array of size dims.... For example, if dims = (3,4,5), then all the following expressions refer to the same key:","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"Q[44]\nQ[2,3,4]\nQ[CartesianIndex(2,3,4)]","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"The storage of a fast priority queue requires prod(dims...)*sizeof(Int) + n*sizeof(T) bytes with n enqueued nodes.","category":"page"},{"location":"priorityqueues/#Common-methods-for-priority-queues","page":"Priority queues","title":"Common methods for priority queues","text":"","category":"section"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"In QuikHeaps, priority queues have a common interface which is described here.","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"The first thing to do with a freshly created priority queue is to populate it. To enqueue key k with priority v in priority queue Q, all the following is equivalent:","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"Q[k] = v\npush!(Q, k => v)\nenqueue!(Q, k => v)\nenqueue!(Q, k, v)","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"Note that key k may already exists in Q; in this case, the priority associated with the key is updated and the queue reorderd if necessary in, at worse, O(log(n)) operations. This is generally faster than first deleting the key and then enqueuing the key with the new priority.","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"To extract the node of highest priority out of the queue Q and get its key k and, possibly, its priority v, call one of:","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"k = dequeue!(Q)\nk, v = pop!(Q)","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"Methods dequeue_pair! and dequeue_node! also extract the root node out of a priority queue and return it as a Pair or as as a node of the type used by the queue.","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"To just examine the node of highest priority, call one of:","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"k, v = peek(Q)\nk, v = first(Q)","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"Like the dequeue! method, the peek method may also be called with a type argument.","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"A priority queue Q behaves like a dictionary:","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"length(Q)         # yields number of nodes\nisempty(Q)        # yields whether priority queue is empty\nempty!(Q)         # empties priority queue\nkeytype(Q)        # yields key type `K`\nvaltype(Q)        # yields value type `V`\nQ[v]              # yields the value of key `k`\nget(Q, k, def)    # query value at key, with default\nQ[k] = v          # set value `v` of key `k`\npush!(Q, k => v)  # idem.\nhaskey(Q, k)      # yields whether key `k` exists\ndelete!(Q, k)     # delete node at key `k`","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"Note that the syntax Q[k] throws an exception if key k does not exists in Q.","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"Finally, there are different ways to iterate on the (unordered) contents of a priority queue Q:","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"keys(Q)                  # yields iterator over keys\nvals(Q)                  # yields iterator over values\nfor (k,v) in Q; ...; end # loop over key-value pairs","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"Note that these iterators yield nodes in their storage order which is not necessarily that of their priority. The order is however the same for these iterators.","category":"page"},{"location":"priorityqueues/#Priority-order","page":"Priority queues","title":"Priority order","text":"","category":"section"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"How are ordered the nodes is completely customizable by specializing the Base.lt method with the following signature:","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"Base.lt(o::OrderingType, a::T, b::T) where {T<:NodeType}","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"which shall yield whether node a has (strictly) higher priority than node b in the queue and where OrderingType and NodeType <: [QuickHeaps.AbstractNode](@ref) are the respective types of the ordering and of the nodes of the priority queue.","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"For the default node type, QuickHeaps.Node{K,V}, the implementation is:","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"Base.lt(o::Ordering, a::T, b::T) where {T<:QuickHeaps.Node} =\n    lt(o, QuickHeaps.getval(a), QuickHeaps.getval(b))","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"where QuickHeaps.getval(a) yields the value of node a. In other words, nodes are sorted by their value according to ordering o.","category":"page"},{"location":"install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"The easiest way to install QuickHeaps is to use Julia's package manager:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"using Pkg\npkg\"add QuickHeaps\"","category":"page"},{"location":"nodes/#Nodes-types","page":"Nodes types","title":"Nodes types","text":"","category":"section"},{"location":"nodes/","page":"Nodes types","title":"Nodes types","text":"Nodes in priority queues provided by QuickHeaps have super-type:","category":"page"},{"location":"nodes/","page":"Nodes types","title":"Nodes types","text":"QuickHeaps.AbstractNode{K,V}","category":"page"},{"location":"nodes/","page":"Nodes types","title":"Nodes types","text":"with K and V the respective types of the key and of the value of the node. In principle, priority of a node is based on its value, but this may be changed by using custom node and/or ordering types.","category":"page"},{"location":"nodes/","page":"Nodes types","title":"Nodes types","text":"Having a specific node type different than, say, Pair{K,V} is to allow customizing how the nodes are compared for ordering by specializing Base.lt without type-piracy.","category":"page"},{"location":"nodes/","page":"Nodes types","title":"Nodes types","text":"A node x can be iterated and converted into a pair or a 2-tuple of its key k and its value v and conversely:","category":"page"},{"location":"nodes/","page":"Nodes types","title":"Nodes types","text":"k, v = x                # extract key and value of a node\nPair(x)                 # yields k=>v\nTuple(x)                # yields (k,v)\nQuickHeaps.Node((k, v)) # is the same as QuickHeaps.Node(k, v)\nQuickHeaps.Node(k => v) # is the same as QuickHeaps.Node(k, v)","category":"page"},{"location":"nodes/","page":"Nodes types","title":"Nodes types","text":"The getkey and (unexported) QuickHeaps.getval methods respectively retrieve the key and the value of a node. These two methods may be specialized for a given sub-type of QuickHeaps.AbstractNode. For example, a key-only node type can be fully implemented by:","category":"page"},{"location":"nodes/","page":"Nodes types","title":"Nodes types","text":"struct KeyOnlyNode{K} <: QuickHeaps.AbstractNode{K,Nothing}\n    key::K\nend\nQuickHeaps.getkey(x::KeyOnlyNode) = getfield(x, :key)\nQuickHeaps.getval(x::KeyOnlyNode) = nothing\nKeyOnlyNode(x::Tuple{K,Nothing}) where {K} = KeyOnlyNode{K}(x[1])\nKeyOnlyNode(x::Pair{K,Nothing}) where {K} = KeyOnlyNode{K}(x.first)","category":"page"},{"location":"nodes/","page":"Nodes types","title":"Nodes types","text":"To provide your own ordring rules, you may specialize Base.lt which otherwise defaults to:","category":"page"},{"location":"nodes/","page":"Nodes types","title":"Nodes types","text":"Base.lt(o::Ordering, a::QuickHeaps.AbstractNode, b::QuickHeaps.AbstractNode) =\n    lt(o, QuickHeaps.getval(a), QuickHeaps.getval(b))","category":"page"},{"location":"binaryheaps/#Binary-heaps","page":"Binary heaps","title":"Binary heaps","text":"","category":"section"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"Binary heaps dynamically store values in a tree structure built according to a given ordering of these values. Thanks to this structure, a number of operations can be efficiently implemented. For a binary heap of n values, pushing a new value, extracting the least (or the greatest depending on the ordering) value out of the heap, deleting a value, and replacing a value all have a complexity of O(log(n)) at worst. Just getting the least (or the greatest) value without extracting it out of the heap is an O(1) operation.","category":"page"},{"location":"binaryheaps/#Basic-usage","page":"Binary heaps","title":"Basic usage","text":"","category":"section"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"In QuickHeaps, a binary heap is created by the BinaryHeap constructor:","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"h = BinaryHeap{T}(o = FastMin)","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"where T is the type of the values stored by the heap and o::Ordering is the ordering rule for sorting values. The default FastMin ordering yields a min-heap whose root entry is the smallest one. With o = ReverseOrdering(FastMin) or o = FastMax, a max-heap is created. The root element of a min-heap (resp. a max-heap) is the smallest one (resp. the greatest one).","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"warning: Warning\nOrdering FastMin (resp. FastMax) is like Forward (resp. Reverse) but much faster for floating-point values. However, FastMin and FastMax are not consistent with NaN (Not a Number) values. If your data may contains NaNs, use Forward or Reverse instead of FastMin or FastMax. Aliases SafeMin=Forward (and SafeMax=Reverse) are provided by the QuickHeaps package.","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"A vector vals storing the initial values of the binary heap can be specified:","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"h = BinaryHeap{T}(vals, o = FastMin)","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"to create a binary heap starting with the values in vals. Type parameter T can be omitted to assume T=eltype(vals). The initial values need not be ordered, the BinaryHeap constructor automatically takes care of that. If vals is a Vector instance with elements of type T, the binary-heap will be directly built into vals. Call BinaryHeap(copy(vals)) to create a binary heap with its own storage.","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"A binary heap h can be used as an ordered queue of values:","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"pop!(h)     # yields the root value and discard it from the heap\npush!(h, x) # pushes value x in heap h","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"The root value is the first one according to the ordering of the heap. To examine the root value without discarding it from the heap, call either of:","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"peek(h)\nfirst(h)\nh[1]","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"A binary heap h behaves like an abstract vector (with 1-based linear indices), in particular:","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"length(h)   # yields the number of values in heap h\nh[i]        # yields the i-th value of heap h\nh[i] = x    # sets the i-th value of heap h and heapify h","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"Note that h[1] is the value of the root entry of the heap h (the least heap values for a min-heap, the greatest heap value for a max-heap) and that setting a value in the heap may trigger reordering of the values stored by the heap to maintain the binary heap structure. In particular, after doing h[i] = x, do not assume that h[i] yields x.","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"To delete the i-th value from the heap h, call:","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"delete!(h, i)","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"Call empty!(h) to delete all the values of the binary heap h and isempty(h) to query whether h is empty.","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"note: Note\nOperations that modify the heap, like deletion by delete!(h,i), insertion by h[i] = x, pushing by push!(h,x), and extracting by pop!(h) are of numerical complexity O(1) in the best case, O(log(n)) in the worst case, with n = length(h) the number of values in the heap h. Query a given value with peek(h), first(h), or h[i] is always of complexity O(1).","category":"page"},{"location":"binaryheaps/#Advanced-usage","page":"Binary heaps","title":"Advanced usage","text":"","category":"section"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"Instances of BinaryHeap store their values in a Julia vector whose length is always equal to the number of stored values. Slightly faster binary heaps are created by the FastBinaryHeap constructor. Such binary heaps never automatically reduce the size of the array backing the storage of their values (even though the size is automatically augmented as needed). You may call resize!(h) to explicitly reduce the storage to its minimum.","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"A hint about the anticipated size n of a heap h (of any kind) can be set by:","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"sizehint!(h, n)","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"which yields h.","category":"page"},{"location":"binaryheaps/#Customize-binary-heaps","page":"Binary heaps","title":"Customize binary heaps","text":"","category":"section"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"The behavior of the binary heap types provided by QuickHeaps can be tweaked by using a particular instance of the ordering o::Ordering and by specializing the Base.lt method called as Base.lt(o,x,y) to decide whether value x occurs before value y according to ordering o. Note that in the implementation of binary heaps in the QuickHeaps package, x and y will always be both of type T, the type of the values stored by the heap.","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"If this is not sufficient, a custom binary heap type may be created that inherits from AbstractBinaryHeap{T,O} with T the type of the values stored by the heap and O the type of the ordering. Assuming the array backing the storage of the values in the custom heap type has 1-based linear indexing, it is sufficient to specialize the following methods for an instance h of the custom heap type, say CustomBinaryHeap:","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"Base.length(h::CustomBinaryHeap) yields the number of values in h;\nBase.empty!(h::CustomBinaryHeap) delete all values in h;\nQuickHeaps.storage(h::CustomBinaryHeap) yields the array backing the storage of values;\nQuickHeaps.ordering(h::CustomBinaryHeap)] yields the ordering of the values;\nQuickHeaps.unsafe_grow!(h::CustomBinaryHeap)\nQuickHeaps.unsafe_shrink!(h::CustomBinaryHeap)","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"to have a fully functional custom binary heap type.","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"By default, Base.resize!(h) does nothing (except returning its argument) for any instance h of a type that inherits from AbstractBinaryHeap; but this method may also be specialized.","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"The QuickHeaps package provides a number of methods (some unexported) that may be useful for implementing new binary heap types:","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"QuickHeaps.heapify\nQuickHeaps.heapify!\nQuickHeaps.isheap\nQuickHeaps.heapify_down!\nQuickHeaps.heapify_up!\nQuickHeaps.unsafe_heapify_down!\nQuickHeaps.unsafe_heapify_up!","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"Note that the heapify, heapify!, and isheap methods which are exported by the QuickHeaps package have the same behavior but are different than those in the DataStructures package. If you are using both packages, you'll have to explicitly prefix these methods by the package module.","category":"page"},{"location":"binaryheaps/#Simple-priority-queues","page":"Binary heaps","title":"Simple priority queues","text":"","category":"section"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"A binary heap can be used to implement a simple priority queue with keys of type K and values of type V as follows:","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"struct Node{K,V}\n   key::K\n   val::V\nend\nBase.lt(o::Base.Ordering, a::T, b::T) where {T<:Node} = lt(o, a.val, b.val)\nQ = FastBinaryHeap{Node}()","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"This simple priority queue is a binary heap (a min-heap in that case) of nodes storing key-value pairs which as sorted according to their values. The same Node structure as the one defined above and with the same specialization of Base.lt is provided (but not exported) by QuickHeaps, so a simplified version of the above example is:","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"using QuickHeaps: Node\nQ = FastBinaryHeap{Node}()","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"Such a priority queue is faster than DataStructures.PriorityQueue but it provides no means to requeue a node nor to ensure that keys are unique. An auxiliary array, a dictionary, or a set can be used for that, this is implemented by QuickHeaps.PriorityQueue and QuickHeaps.FastPriorityQueue which are more flexible and offer more capabilities than the simple implementation in the above example.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"QuickHeaps is a Julia package providing versatile binary heaps and priority queues. These data structures are more flexible and may be quite significantly faster than those provided by DataStructures.","category":"page"},{"location":"#Table-of-contents","page":"Introduction","title":"Table of contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\"install.md\", \"binaryheaps.md\", \"priorityqueues.md\",\n    \"nodes.md\", \"library.md\"]","category":"page"},{"location":"#Index-of-types-and-methods","page":"Introduction","title":"Index of types and methods","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"}]
}
