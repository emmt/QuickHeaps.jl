<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Binary heaps · Efficient and versatile binary heaps and priority queues for Julia</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Efficient and versatile binary heaps and priority queues for Julia</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../install/">Installation</a></li><li class="is-active"><a class="tocitem" href>Binary heaps</a><ul class="internal"><li><a class="tocitem" href="#Basic-usage"><span>Basic usage</span></a></li><li><a class="tocitem" href="#Simple-priority-queues"><span>Simple priority queues</span></a></li></ul></li><li><a class="tocitem" href="../priorityqueues/">Priority queues</a></li><li><a class="tocitem" href="../nodes/">Nodes types</a></li><li><a class="tocitem" href="../library/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Binary heaps</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Binary heaps</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/emmt/QuickHeaps.jl/blob/master/docs/src/binaryheaps.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Binary-heaps"><a class="docs-heading-anchor" href="#Binary-heaps">Binary heaps</a><a id="Binary-heaps-1"></a><a class="docs-heading-anchor-permalink" href="#Binary-heaps" title="Permalink"></a></h1><p><a href="https://en.wikipedia.org/wiki/Binary_heap">Binary heaps</a> dynamically store values in a tree structure built according to a given ordering of these values. Thanks to this structure, a number of operations can be efficiently implemented. For a binary heap of <code>n</code> values, pushing a new value, extracting the least (or the greatest depending on the ordering) value out of the heap, deleting a value, and replacing a value all have a complexity of <code>O(log(n))</code> at worst. Just getting the least (or the greatest) value without extracting it out of the heap is an <code>O(1)</code> operation.</p><h2 id="Basic-usage"><a class="docs-heading-anchor" href="#Basic-usage">Basic usage</a><a id="Basic-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-usage" title="Permalink"></a></h2><p>In <code>QuickHeaps</code>, a binary heap is created by the <a href="../library/#QuickHeaps.BinaryHeap"><code>BinaryHeap</code></a> constructor:</p><pre><code class="language-julia hljs">h = BinaryHeap{T}(o = FastMin)</code></pre><p>where <code>T</code> is the type of the values stored by the heap and <code>o::Ordering</code> is the ordering rule for sorting values. The default <code>FastMin</code> ordering yields a <em>min-heap</em> whose root entry is the smallest one. With <code>o = ReverseOrdering(FastMin)</code> or <code>o = FastMax</code>, a <em>max-heap</em> is created. The root element of a min-heap (resp. a max-heap) is the smallest one (resp. the greatest one).</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Ordering <code>FastMin</code> (resp. <code>FastMax</code>) is like <code>Forward</code> (resp. <code>Reverse</code>) but much faster for floating-point values. However, <code>FastMin</code> and <code>FastMax</code> are not consistent with NaN (<em>Not a Number</em>) values. If your data may contains NaNs, use <code>Forward</code> or <code>Reverse</code> instead of <code>FastMin</code> or <code>FastMax</code>. Aliases <code>SafeMin=Forward</code> (and <code>SafeMax=Reverse</code>) are provided by the <code>QuickHeaps</code> package.</p></div></div><p>A vector <code>vals</code> storing the initial values of the binary heap can be specified:</p><pre><code class="language-julia hljs">h = BinaryHeap{T}(vals, o = FastMin)</code></pre><p>to create a binary heap starting with the values in <code>vals</code>. Type parameter <code>T</code> can be omitted to assume <code>T=eltype(vals)</code>. The initial values need not be ordered, the <code>BinaryHeap</code> constructor automatically takes care of that. If <code>vals</code> is a <code>Vector</code> instance with elements of type <code>T</code>, the binary-heap will be directly built into <code>vals</code>. Call <code>BinaryHeap(copy(vals))</code> to create a binary heap with its own storage.</p><p>A binary heap <code>h</code> can be used as an ordered queue of values:</p><pre><code class="language-julia hljs">pop!(h)     # yields the root value and discard it from the heap
push!(h, x) # pushes value x in heap h</code></pre><p>The <em>root</em> value is the first one according to the ordering of the heap. To examine the root value without discarding it from the heap, call either of:</p><pre><code class="language-julia hljs">peek(h)
first(h)
h[1]</code></pre><p>A binary heap <code>h</code> behaves like an abstract vector (with 1-based linear indices), in particular:</p><pre><code class="language-julia hljs">length(h)   # yields the number of values in heap h
h[i]        # yields the i-th value of heap h
h[i] = x    # sets the i-th value of heap h and heapify h</code></pre><p>Note that <code>h[1]</code> is the value of the root entry of the heap <code>h</code> (the least heap values for a min-heap, the greatest heap value for a max-heap) and that setting a value in the heap may trigger reordering of the values stored by the heap to maintain the binary heap structure. In particular, after doing <code>h[i] = x</code>, do not assume that <code>h[i]</code> yields <code>x</code>.</p><p>To delete the <code>i</code>-th value from the heap <code>h</code>, call:</p><pre><code class="language-julia hljs">delete!(h, i)</code></pre><p>Call <code>empty!(h)</code> to delete all the values of the binary heap <code>h</code> and <code>isempty(h)</code> to query whether <code>h</code> is empty.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Operations that modify the heap, like deletion by <code>delete!(h,i)</code>, insertion by <code>h[i] = x</code>, pushing by <code>push!(h,x)</code>, and extracting by <code>pop!(h)</code> are of numerical complexity <code>O(1)</code> in the best case, <code>O(log(n))</code> in the worst case, with <code>n = length(h)</code> the number of values in the heap <code>h</code>. Query a given value with <code>peek(h)</code>, <code>first(h)</code>, or <code>h[i]</code> is always of complexity <code>O(1)</code>.</p></div></div><h3 id="Advanced-usage"><a class="docs-heading-anchor" href="#Advanced-usage">Advanced usage</a><a id="Advanced-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Advanced-usage" title="Permalink"></a></h3><p>Instances of <a href="../library/#QuickHeaps.BinaryHeap"><code>BinaryHeap</code></a> store their values in a Julia vector whose length is always equal to the number of stored values. Slightly faster binary heaps are created by the <a href="../library/#QuickHeaps.FastBinaryHeap"><code>FastBinaryHeap</code></a> constructor. Such binary heaps never automatically reduce the size of the array backing the storage of their values (even though the size is automatically augmented as needed). You may call <code>resize!(h)</code> to explicitly reduce the storage to its minimum.</p><p>A hint about the anticipated size <code>n</code> of a heap <code>h</code> (of any kind) can be set by:</p><pre><code class="language-julia hljs">sizehint!(h, n)</code></pre><p>which yields <code>h</code>.</p><h3 id="Customize-binary-heaps"><a class="docs-heading-anchor" href="#Customize-binary-heaps">Customize binary heaps</a><a id="Customize-binary-heaps-1"></a><a class="docs-heading-anchor-permalink" href="#Customize-binary-heaps" title="Permalink"></a></h3><p>The behavior of the binary heap types provided by <code>QuickHeaps</code> can be tweaked by using a particular instance of the ordering <code>o::Ordering</code> and by specializing the <code>Base.lt</code> method called as <code>Base.lt(o,x,y)</code> to decide whether value <code>x</code> occurs before value <code>y</code> according to ordering <code>o</code>. Note that in the implementation of binary heaps in the <code>QuickHeaps</code> package, <code>x</code> and <code>y</code> will always be both of type <code>T</code>, the type of the values stored by the heap.</p><p>If this is not sufficient, a custom binary heap type may be created that inherits from <code>AbstractBinaryHeap{T,O}</code> with <code>T</code> the type of the values stored by the heap and <code>O</code> the type of the ordering. Assuming the array backing the storage of the values in the custom heap type has 1-based linear indexing, it is sufficient to specialize the following methods for an instance <code>h</code> of the custom heap type, say <code>CustomBinaryHeap</code>:</p><ul><li><code>Base.length(h::CustomBinaryHeap)</code> yields the number of values in <code>h</code>;</li><li><code>Base.empty!(h::CustomBinaryHeap)</code> delete all values in <code>h</code>;</li><li><a href="../library/#QuickHeaps.storage"><code>QuickHeaps.storage</code></a><code>(h::CustomBinaryHeap)</code> yields the array backing the storage of values;</li><li><a href="../library/#QuickHeaps.ordering"><code>QuickHeaps.ordering</code></a><code>(h::CustomBinaryHeap)</code>] yields the ordering of the values;</li><li><a href="../library/#QuickHeaps.unsafe_grow!"><code>QuickHeaps.unsafe_grow!</code></a><code>(h::CustomBinaryHeap)</code></li><li><a href="../library/#QuickHeaps.unsafe_shrink!"><code>QuickHeaps.unsafe_shrink!</code></a><code>(h::CustomBinaryHeap)</code></li></ul><p>to have a fully functional custom binary heap type.</p><p>By default, <code>Base.resize!(h)</code> does nothing (except returning its argument) for any instance <code>h</code> of a type that inherits from <code>AbstractBinaryHeap</code>; but this method may also be specialized.</p><p>The <code>QuickHeaps</code> package provides a number of methods (some unexported) that may be useful for implementing new binary heap types:</p><ul><li><a href="../library/#QuickHeaps.heapify"><code>QuickHeaps.heapify</code></a></li><li><a href="../library/#QuickHeaps.heapify!"><code>QuickHeaps.heapify!</code></a></li><li><a href="../library/#QuickHeaps.isheap"><code>QuickHeaps.isheap</code></a></li><li><a href="../library/#QuickHeaps.heapify_down!"><code>QuickHeaps.heapify_down!</code></a></li><li><a href="../library/#QuickHeaps.heapify_up!"><code>QuickHeaps.heapify_up!</code></a></li><li><a href="../library/#QuickHeaps.unsafe_heapify_down!"><code>QuickHeaps.unsafe_heapify_down!</code></a></li><li><a href="../library/#QuickHeaps.unsafe_heapify_up!"><code>QuickHeaps.unsafe_heapify_up!</code></a></li></ul><p>Note that the <code>heapify</code>, <code>heapify!</code>, and <code>isheap</code> methods which are exported by the <code>QuickHeaps</code> package have the same behavior but are different than those in the <a href="https://github.com/JuliaCollections/DataStructures.jl"><code>DataStructures</code></a> package. If you are using both packages, you&#39;ll have to explicitly prefix these methods by the package module.</p><h2 id="Simple-priority-queues"><a class="docs-heading-anchor" href="#Simple-priority-queues">Simple priority queues</a><a id="Simple-priority-queues-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-priority-queues" title="Permalink"></a></h2><p>A binary heap can be used to implement a simple <a href="https://en.wikipedia.org/wiki/Priority_queue">priority queue</a> with keys of type <code>K</code> and values of type <code>V</code> as follows:</p><pre><code class="language-julia hljs">struct Node{K,V}
   key::K
   val::V
end
Base.lt(o::Base.Ordering, a::T, b::T) where {T&lt;:Node} = lt(o, a.val, b.val)
Q = FastBinaryHeap{Node}()</code></pre><p>This simple priority queue is a binary heap (a <em>min-heap</em> in that case) of nodes storing key-value pairs which as sorted according to their values. The same <code>Node</code> structure as the one defined above and with the same specialization of <code>Base.lt</code> is provided (but not exported) by <code>QuickHeaps</code>, so a simplified version of the above example is:</p><pre><code class="language-julia hljs">using QuickHeaps: Node
Q = FastBinaryHeap{Node}()</code></pre><p>Such a priority queue is faster than <code>DataStructures.PriorityQueue</code> but it provides no means to requeue a node nor to ensure that keys are unique. An auxiliary array, a dictionary, or a set can be used for that, this is implemented by <a href="../library/#QuickHeaps.PriorityQueue"><code>QuickHeaps.PriorityQueue</code></a> and <a href="../library/#QuickHeaps.FastPriorityQueue"><code>QuickHeaps.FastPriorityQueue</code></a> which are more flexible and offer more capabilities than the simple implementation in the above example.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../install/">« Installation</a><a class="docs-footer-nextpage" href="../priorityqueues/">Priority queues »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 8 September 2025 16:12">Monday 8 September 2025</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
