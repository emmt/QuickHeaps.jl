module TestingBinaryHeaps

using Test

using Base.Order: Ordering, Forward, Reverse, lt

using QuickHeaps
using QuickHeaps: storage

orientation(::Any) = 0
orientation(h::AbstractBinaryHeap) = orientation(typeof(h))
orientation(::Type{<:AbstractBinaryHeap{T,O}}) where {T,O} = orientation(O)
orientation(o::Ordering) = orientation(typeof(o))
orientation(::Type{<:Union{typeof(Forward),typeof(TotalMin),typeof(FastMin)}}) = +1
orientation(::Type{typeof(TotalMax)}) = -1
orientation(::Type{<:Base.Order.ReverseOrdering{O}}) where {O} = -orientation(O)

is_min_ordering(x) = orientation(x) > 0
is_max_ordering(x) = orientation(x) < 0

function is_sorted(o::Ordering, x::AbstractVector)
    flag = false
    for i in 2:length(x)
        flag |= lt(o, x[i], x[i-1])
    end
    return !flag
end

other_type(::Type{Float64}) = Float32
other_type(::Type{Float32}) = Float64
other_type(::Type{Int16}) = Int32
other_type(::Type{Int32}) = Int16
other_type(::Type{Int64}) = Int32
other_type(::Type{UInt16}) = UInt32
other_type(::Type{UInt32}) = UInt16
other_type(::Type{UInt64}) = UInt32

# In Julia 1.0 "$o" with o=nothing is an error, so provide our own singleton type
# to represent unspecified argument.
struct Nil end
const nil = Nil()
Base.print(io::IO, ::Nil) = nothing

# Yields a non-heap vector of the values.
vals(h::BinaryHeap) = storage(h)
vals(h::AbstractBinaryHeap) = view(storage(h), Base.OneTo(length(h)))

# Checks whether 2 arrays have the same entries although not nceessarily in the same
# order.
same_entries(A::AbstractArray, B::AbstractArray) = sort(vec(A)) == sort(vec(B))

# A1 and A2 are two arrays such that view(A,1:i) is not a heap in any ordering
# for A = A1 or A2 and i â‰¥ 3. These arrays where randomly generated by
# something like:
#     A1 = rand(1:15, 16)
#     A2 = map(x->round(Int,100*x)/10, rand(Float64, 11))
# with some manual re-ordering of the 3 first entries to ensure that the
# non-heap property holds.
const A1 = [7, 12, 5, 13, 6, 14, 12, 1, 10, 6, 9, 4, 10, 7, 12, 14];
const A2 = [3.0, 6.4, 1.1, 9.2, 1.2, 8.2, 1.3, 7.9, 9.1, 2.3, 8.2];

@testset "Arrays as binary heaps" begin
    for (A, dir) in (
        ([1, 4, 2, 6, 5, 3, 8, 7, 11, 13, 10, 14, 9, 12], +1), # min-heap
        ([14, 11, 13, 9, 10, 12, 7, 8, 4, 2, 5, 1, 6, 3], -1), # max-heap
        ([13, 1, 14, 8, 10, 9, 7, 2, 5, 4, 12, 3, 6, 11],  0), # not heap
        )
        n = length(A)
        flag = (dir > 0)
        success = true
        @test flag == isheap(A)
        for np in 3:n # last elements can be discarded
            success &= (flag == isheap(A, np))
        end
        @test success
        for o in (Forward, TotalMin, FastMin, Reverse, TotalMax, FastMax)
            flag = (dir*orientation(o) > 0)
            @test flag == isheap(A, o)
            @test flag == isheap(o, A)
            @test flag == isheap(A, n, o)
            @test flag == isheap(A, o, Int16(n))
            success = true
            for np in 3:n # last elements can be discarded
                success &= (flag == isheap(o, A, np))
            end
            @test success
        end
        B = heapify(A)
        @test same_entries(A, B)
        @test isheap(B)
        @test !isheap(B, Reverse)
        QuickHeaps.heapify_down!(Forward, B, 1, Int16(1234))
        @test isheap(Forward, B)
        QuickHeaps.heapify_up!(Forward, B, length(B), Int16(-789))
        @test isheap(Forward, B)

        B = heapify(A, Reverse, Int16(n))
        @test same_entries(A, B)
        @test !isheap(B)
        @test isheap(B, Reverse)

        C = copy(A)
        B = heapify!(C)
        @test same_entries(A, B)
        @test B === C
        @test isheap(B)

        B = heapify!(C, Reverse, Int16(n))
        @test same_entries(A, B)
        @test B === C
        @test isheap(B, Reverse)
        QuickHeaps.heapify_down!(Reverse, B, 1, Int16(-1234))
        @test isheap(B, Reverse)
        QuickHeaps.heapify_up!(Reverse, B, length(B), Int16(789))
        @test isheap(B, Reverse)
    end
end

@testset "Binary heaps          " begin
    @test QuickHeaps.default_ordering(AbstractBinaryHeap) === TotalMin
    @test QuickHeaps.default_ordering(FastBinaryHeap) === TotalMin
    pass = 0
    for o in (nil, TotalMin, TotalMax, FastMin, FastMax),
        B in (BinaryHeap, FastBinaryHeap), A in (A1, A2)
        pass += 1
        n = length(A)
        T = eltype(A)
        S = other_type(T)
        expected_ordering = (o === nil ? TotalMin : o)

        # Build an empty binary-heap and fill it.
        h1 = (o === nil ? B{T}() : B{T}(o))
        @test eltype(h1) == T
        @test IndexStyle(h1) == IndexLinear()
        @test length(h1) == 0
        @test size(h1) == (0,)
        @test isempty(h1)
        @test isheap(h1) && isheap(h1; check=true) && isheap(h1; check=false)
        @test_throws ArgumentError peek(h1)
        @test_throws ArgumentError pop!(h1)
        @test Ordering(h1) === expected_ordering

        # Start with given array without specifying type.
        h2 = (o === nil ? B(copy(A)) : T <: Integer ? B(o, copy(A)) : B(copy(A), o))
        @test Ordering(h2) === expected_ordering
        @test eltype(h2) == T
        @test IndexStyle(h2) == IndexLinear()
        @test length(h2) == n
        @test size(h2) == (n,)
        @test !isempty(h2)
        @test isheap(h2) && isheap(h2; check=true) && isheap(h2; check=false)
        @test same_entries(h2, A)

        # Start with given array and specifying the same element type.
        h3 = (o === nil ? B{T}(copy(A)) : T <: Integer ? B{T}(o, copy(A)) : B{T}(copy(A), o))
        @test Ordering(h3) === expected_ordering
        @test eltype(h3) == T
        @test IndexStyle(h3) == IndexLinear()
        @test length(h3) == n
        @test size(h3) == (n,)
        @test !isempty(h3)
        @test isheap(h3) && isheap(h3; check=true) && isheap(h3; check=false)
        @test same_entries(h3, A)

        # Start with given array and specifying another element type.
        h4 = (o === nil ? B{S}(A) : S <: Integer ? B{S}(A, o) : B{S}(o, A))
        @test Ordering(h4) === expected_ordering
        @test eltype(h4) == S
        @test IndexStyle(h4) == IndexLinear()
        @test length(h4) == n
        @test size(h4) == (n,)
        @test !isempty(h4)
        @test isheap(h4) && isheap(h4; check=true) && isheap(h4; check=false)
        @test same_entries(h4, convert(Vector{S}, A))

        # Do not repeat the following tests for default ordering.
        o === nil && continue

        # Fill empty heap with values.
        isodd(pass) && sizehint!(h1, n)
        for i in 1:n
            if T <: Integer
                # Push entry with different type but not actually changing value.
                push!(h1, convert(S, A[i]))
            else
                push!(h1, A[i])
            end
            @test isheap(h1; check=true)
            @test !isempty(h1)
            v1 = (is_min_ordering(h1) ? minimum(vals(h1)) : maximum(vals(h1)))
            @test peek(h1) === v1
            @test first(h1) === v1
            @test length(h1) == i
        end
        @test same_entries(h1, A)

        # Empty heap by repeatedly pop root entry and check that entries are extracted
        # in order.
        x1 = eltype(h1)[]
        while !isempty(h1)
            len = length(h1)
            push!(x1, pop!(h1))
            @test length(h1) == len - 1
            @test isheap(h1; check=true)
        end
        @test same_entries(x1, A)
        @test is_sorted(Ordering(h1), x1)
        resize!(h1) # shrink internal buffer

        # Empty heap by deleting entries in somewhat random order.
        x2 = eltype(h2)[]
        while !isempty(h2)
            len = length(h2)
            i = 1 + Int(hash(len) % len) # reproducible pseudo-random index
            push!(x2, h2[i])
            if isodd(len)
                delete!(h2, i)
            else
                delete!(h2, Int16(i))
            end
            @test length(h2) == len - 1
            @test isheap(h2; check=true)
        end
        @test same_entries(x2, A)

        # Empty heap then fill it by pieces.
        @test isempty(empty!(h3))
        push!(h3, A[1:4]...)
        @test length(h3) == 4
        @test isheap(h3; check=true)
        for i in 5:n
            push!(h3, A[i])
        end
        @test same_entries(h3, A)

        # Unsupported methods.
        @test_throws Exception append!(h3, 1)
        @test_throws Exception append!(h3, 1, 2)
        @test_throws Exception prepend!(h3, 1)
        @test_throws Exception prepend!(h3, 1, 2)

        # Perturb heap in different ways.
        vmax = maximum(vals(h4))
        for i in 1:n
            vi = convert(other_type(eltype(h4)), vmax - h4[i])
            if i == 1 && eltype(h4) <: Integer
                # Just take another path to set the first entry.
                QuickHeaps.setroot!(h4, vi)
            else
                # Set i-th entry.
                h4[i] = vi
            end
            @test isheap(h4; check=true)
            @test length(h4) == n
            v1 = (is_min_ordering(h4) ? minimum(vals(h4)) : maximum(vals(h4)))
            @test peek(h4) === v1
            @test first(h4) === v1
        end
    end
end

end # module
