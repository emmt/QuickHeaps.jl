<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · Efficient and versatile binary heaps and priority queues for Julia</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Efficient and versatile binary heaps and priority queues for Julia</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../binaryheaps/">Binary heaps</a></li><li><a class="tocitem" href="../priorityqueues/">Priority queues</a></li><li><a class="tocitem" href="../customize/">Custom order</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Binary-Heaps"><span>Binary Heaps</span></a></li><li><a class="tocitem" href="#Priority-Queues"><span>Priority Queues</span></a></li><li><a class="tocitem" href="#Orderings"><span>Orderings</span></a></li><li><a class="tocitem" href="#Miscellaneous"><span>Miscellaneous</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/emmt/QuickHeaps.jl/blob/master/docs/src/library.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><p>The following reproduces the in-lined documentation about types and methods of the <a href="https://github.com/emmt/QuickHeaps.jl"><code>QuickHeaps</code></a> package. This documentation is also available from the REPL by typing <code>?</code> followed by the name of a method or a type.</p><h2 id="Binary-Heaps"><a class="docs-heading-anchor" href="#Binary-Heaps">Binary Heaps</a><a id="Binary-Heaps-1"></a><a class="docs-heading-anchor-permalink" href="#Binary-Heaps" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.AbstractBinaryHeap" href="#QuickHeaps.AbstractBinaryHeap"><code>QuickHeaps.AbstractBinaryHeap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.AbstractBinaryHeap{T,O}</code></pre><p>is the super-type of binary heaps in <code>QuickHeaps</code> whose values have type <code>T</code> and whose ordering has type <code>O</code>.</p><p>The following methods are available for a binary heap <code>h</code> (those which modify the heap contents re-order heap values as needed to maintain the heap structure):</p><pre><code class="nohighlight hljs">pop!(h)        # deletes and returns root value of heap h
push!(h, x)    # pushes value x in heap h
empty!(h)      # empties heap h
isempty(h)     # yields whether heap h is empty
delete!(h, i)  # deletes i-th value from heap h
peek(h)        # yields root value of heap h without deleting it
first(h)       # idem
setroot!(h, x) # same as h[1] = x, replaces root value of heap h by x</code></pre><p>A binary heap <code>h</code> behaves like an abstract vector (with 1-based linear indices), in particular:</p><pre><code class="nohighlight hljs">length(h)   # the number of values in heap h
h[i]        # the i-th value of heap h
h[i] = x    # set the i-th value of heap h and heapify h</code></pre><p>Note that <code>h[1]</code> is the root value of the heap <code>h</code> and that setting a value in the heap may trigger reordering of the values to maintain the binary heap structure. In other words, after doing <code>h[i] = x</code>, do not assume that <code>h[i]</code> yields <code>x</code>.</p><p>Operations that modify the heap, like deletion by <code>delete!(h,i)</code>, insertion by <code>h[i] = x</code>, pushing by <code>push!(h,x)</code>, and extracting by <code>pop!(h)</code> are of complexity <code>O(1)</code> in the best case, <code>O(log(n))</code> in the worst case, with <code>n = length(h)</code> the number of values in the heap <code>h</code>. Retrieving a given value with <code>peek(h)</code>, <code>first(h)</code>, or <code>h[i]</code> is always of complexity <code>O(1)</code>.</p><p>Call <code>Base.Order.Ordering(h)</code> to retrieve the ordering object <code>o</code> for the binary heap <code>h</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/192b5395cfcf7dcb5ae15262933de6450cacb998/src/types.jl#L76-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.BinaryHeap" href="#QuickHeaps.BinaryHeap"><code>QuickHeaps.BinaryHeap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">h = BinaryHeap{T}([o::Base.Order.Ordering = TotalMin,][ vals::AbstractVector])</code></pre><p>Build an empty binary heap whose values have type <code>T</code> and with ordering specified by <code>o</code>.</p><p>The method <code>Base.Order.lt(o,x::T,y::T)</code> is called to determine the order of values <code>x</code> and <code>y</code> in the heap. The default ordering, <a href="#QuickHeaps.TotalMin"><code>TotalMin</code></a>, yields a <em>min-heap</em> object; with <a href="#QuickHeaps.TotalMax"><code>TotalMax</code></a> ordering, a <em>max-heap</em> object is returned.</p><p>An optional vector <code>vals</code> storing the initial values of the binary heap can be specified. These values in <code>vals</code> need not be ordered, the <code>BinaryHeap</code> constructor automatically takes care of that. If <code>vals</code> is a <code>Vector{T}</code> instance, the binary-heap will be directly built into <code>vals</code>. Call <code>BinaryHeap(copy(vals))</code> to create a binary heap with its own storage.</p><p>Arguments <code>o</code> and <code>vals</code> may be specified in any order.</p><p>Method <code>sizehint!(h,n)</code> may be called to anticipate that the heap may contains <code>n</code> values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/192b5395cfcf7dcb5ae15262933de6450cacb998/src/binaryheaps.jl#L3-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.FastBinaryHeap" href="#QuickHeaps.FastBinaryHeap"><code>QuickHeaps.FastBinaryHeap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">h = FastBinaryHeap{T}([o::Base.Order.Ordering = TotalMin,][ vals::AbstractVector])</code></pre><p>Build a fast binary heap. Compared to <a href="#QuickHeaps.BinaryHeap"><code>BinaryHeap{T}(...)</code></a>, the array backing the storage of the heap values is never automatically reduced to improve performances in some cases. You may call <code>resize!(h)</code> to explicitly reduce the storage of fast binary-heap <code>h</code> to its minimum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/192b5395cfcf7dcb5ae15262933de6450cacb998/src/binaryheaps.jl#L23-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.heapify" href="#QuickHeaps.heapify"><code>QuickHeaps.heapify</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">heapify([o=TotalMin,] A, n=length(A))</code></pre><p>yields an array with the <code>n</code> first values of array <code>A</code> stored in a binary heap structure of ordering specified by <code>o</code>. The storage of the returned heap is a different array than <code>A</code>. Arguments may be specified in any order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/192b5395cfcf7dcb5ae15262933de6450cacb998/src/binaryheaps.jl#L255-L262">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.heapify!" href="#QuickHeaps.heapify!"><code>QuickHeaps.heapify!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">heapify!(h) -&gt; h</code></pre><p>reorders the values in the binary heap <code>h</code> in-place. This method should be called to initialize the heap or to re-order the heap if its contents have been modified by other methods than <code>pop!</code> or <code>push!</code>.</p><p>The method can be called at a lower level to heapify (part of) an array storing the heap values:</p><pre><code class="nohighlight hljs">heapify!([o=TotalMin,] A, n=length(A)) -&gt; A</code></pre><p>reorders the <code>n</code> first elements of array <code>A</code> in-place to form a binary heap according to the ordering specified by <code>o</code>. The array <code>A</code> must have 1-based linear indexing. Arguments may be specified in any order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/192b5395cfcf7dcb5ae15262933de6450cacb998/src/binaryheaps.jl#L222-L238">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.heapify_down!" href="#QuickHeaps.heapify_down!"><code>QuickHeaps.heapify_down!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.heapify_down!(o, A, i, x=A[i], n=lengh(A)) -&gt; A</code></pre><p>stores the value <code>x</code> in the <code>i</code>-th entry of the binary heap built into the <code>n</code> first elements of array <code>A</code> with ordering <code>o</code> and, if needed, moves down the inserted value to maintain the binary heap structure.</p><p>This method is called to <em>heapify</em> an array in order to initialize or rebuild the heap structure or to replace the value of the root value of the heap and update the heap structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/192b5395cfcf7dcb5ae15262933de6450cacb998/src/binaryheaps.jl#L318-L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.heapify_up!" href="#QuickHeaps.heapify_up!"><code>QuickHeaps.heapify_up!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>QuickHeaps.heapify_up!(o, A, i, x=A[i]) -&gt; A</p><p>stores the value <code>x</code> in the <code>i</code>-th entry of the binary heap built into the <code>i</code> first elements of array <code>A</code> with ordering <code>o</code> and, if needed, moves up the value to maintain the heap structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/192b5395cfcf7dcb5ae15262933de6450cacb998/src/binaryheaps.jl#L367-L374">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.isheap" href="#QuickHeaps.isheap"><code>QuickHeaps.isheap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isheap([o=TotalMin,], A, n=length(A))</code></pre><p>yields whether the <code>n</code> first elements of array <code>A</code> have a binary heap structure ordered as specified by <code>o</code>. Arguments may be specified in any order.</p><pre><code class="nohighlight hljs">isheap(obj; check=false)</code></pre><p>yields whether object <code>obj</code> is a binary heap. If keyword <code>check</code> is true, the internal structure of <code>obj</code> is checked; otherwise, the type of <code>obj</code> is trusted to determine whether it is a binary heap.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/192b5395cfcf7dcb5ae15262933de6450cacb998/src/binaryheaps.jl#L268-L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.unsafe_heapify_down!" href="#QuickHeaps.unsafe_heapify_down!"><code>QuickHeaps.unsafe_heapify_down!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.unsafe_heapify_down!(o, A, i, x=A[i], n=lengh(A))</code></pre><p>This method is a fast but <em>unsafe</em> version of <a href="#QuickHeaps.heapify_down!"><code>QuickHeaps.heapify_down!</code></a> which assumes that all arguments are correct, that is <code>A</code> implements 1-based linear indexing, <code>0 ≤ n ≤ lengh(A)</code>, and <code>1 ≤ i ≤ n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/192b5395cfcf7dcb5ae15262933de6450cacb998/src/binaryheaps.jl#L343-L350">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.unsafe_heapify_up!" href="#QuickHeaps.unsafe_heapify_up!"><code>QuickHeaps.unsafe_heapify_up!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.unsafe_heapify_up!(o, A, i, x=A[i])</code></pre><p>This methods is a fast but <em>unsafe</em> version of <a href="#QuickHeaps.heapify_up!"><code>QuickHeaps.heapify_up!</code></a> which assumes that all arguments are correct, that is <code>A</code> implements 1-based linear indexing and <code>1 ≤ i ≤ length(A)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/192b5395cfcf7dcb5ae15262933de6450cacb998/src/binaryheaps.jl#L387-L394">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.unsafe_grow!" href="#QuickHeaps.unsafe_grow!"><code>QuickHeaps.unsafe_grow!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.unsafe_grow!(h, n) -&gt; A</code></pre><p>grows the size of the binary heap <code>h</code> to be <code>n</code> and returns the array <code>A</code> backing the storage of the values. This method is <em>unsafe</em> because it does not check its arguments and because it breaks the binary heap structure of the array of values.</p><p>This method is called by <code>push!</code> to grow the size of the heap and shall be specialized for any concrete sub-types of <code>QuickHeaps.AbstractBinaryHeap</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/192b5395cfcf7dcb5ae15262933de6450cacb998/src/binaryheaps.jl#L190-L200">source</a></section><section><div><pre><code class="nohighlight hljs">QuickHeaps.unsafe_grow!(pq, n) -&gt; pq</code></pre><p>grows the size of the binary heap backing the storage of the entries of the priority queue <code>pq</code> to be <code>n</code> and returns the priority queue object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/192b5395cfcf7dcb5ae15262933de6450cacb998/src/priorityqueues.jl#L402-L408">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.unsafe_shrink!" href="#QuickHeaps.unsafe_shrink!"><code>QuickHeaps.unsafe_shrink!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.unsafe_shrink!(h, n)</code></pre><p>shrinks the size of the binary heap <code>h</code> to be <code>n</code>. This method is <em>unsafe</em> because it does not check its arguments.</p><p>This method is called by <code>delete!</code> to eventually reduce the size of the heap and shall be specialized for any concrete sub-type of <a href="#QuickHeaps.AbstractBinaryHeap"><code>QuickHeaps.AbstractBinaryHeap</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/192b5395cfcf7dcb5ae15262933de6450cacb998/src/binaryheaps.jl#L209-L218">source</a></section><section><div><pre><code class="nohighlight hljs">QuickHeaps.unsafe_shrink!(pq, n)</code></pre><p>shrinks the size of the binary heap backing the storage of the entries of the priority queue <code>pq</code> to be <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/192b5395cfcf7dcb5ae15262933de6450cacb998/src/priorityqueues.jl#L414-L420">source</a></section></article><h2 id="Priority-Queues"><a class="docs-heading-anchor" href="#Priority-Queues">Priority Queues</a><a id="Priority-Queues-1"></a><a class="docs-heading-anchor-permalink" href="#Priority-Queues" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.AbstractPriorityQueue" href="#QuickHeaps.AbstractPriorityQueue"><code>QuickHeaps.AbstractPriorityQueue</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.AbstractPriorityQueue{K,V,O}</code></pre><p>is the super type of priority queues with ordering of type <code>O&lt;:Base.Order.Ordering</code> and storing keys of type <code>K</code> associated priority values of type <code>V</code>.</p><p>Package <code>QuickHeaps</code> provides two concrete types of priority queues: <a href="#QuickHeaps.PriorityQueue"><code>PriorityQueue</code></a> for any kind of keys and <a href="#QuickHeaps.FastPriorityQueue"><code>FastPriorityQueue</code></a> for which keys are analogous to array indices.</p><p>Priority queues behave like dictionaries with the additional feature of automatically maintaining an ordered structure according to the priority queue ordering and the entry values. For a priority queue <code>pq</code>, retrieving the <em>root</em> entry, that is the pair <code>key =&gt; val</code> of highest priority, without removing it costs <code>O(1)</code> and is done by:</p><pre><code class="nohighlight hljs">peek(pq) -&gt; (key =&gt; val)</code></pre><p>Retrieving the value of an entry given its <code>key</code> has also an <code>O(1)</code> complexity and is done by one of:</p><pre><code class="nohighlight hljs">pq[key...] -&gt; val
getindex(pq, key...) -&gt; val
get(pq, key, def) -&gt; val_at_key_or_def</code></pre><p>Changing the content of the priority queue has a complexity of <code>O(log(n))</code> with <code>n = length(pq)</code> the number of queued entries. This includes removing the entry at <code>key</code> by:</p><pre><code class="nohighlight hljs">delete!(pq, key) -&gt; pq
pop!(pq, key) -&gt; val
pop!(pq, key, def) -&gt; val_or_def</code></pre><p>removing the root entry by:</p><pre><code class="nohighlight hljs">pop!(pq)          # -&gt; root entry as a `key=&gt;val` pair
dequeue!(pq)      # -&gt; key of root entry
dequeue_pair!(pq) # -&gt; root entry as a `key=&gt;val` pair</code></pre><p>or setting/changing an entry with a given <code>key</code> and value <code>val</code> by one of:</p><pre><code class="nohighlight hljs">pq[key] = val
enqueue!(pq, key =&gt; val)
push!(pq, key =&gt; val)</code></pre><p>Call <code>Base.Order.Ordering(pq)</code> to retrieve the ordering object <code>o</code> for the priority queue <code>pq</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/192b5395cfcf7dcb5ae15262933de6450cacb998/src/types.jl#L135-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.PriorityQueue" href="#QuickHeaps.PriorityQueue"><code>QuickHeaps.PriorityQueue</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PriorityQueue{K,V}(o=TotalMin)</code></pre><p>yields a priority queue for keys of type <code>K</code> and priority values of type <code>V</code>. Optional argument <code>o::Ordering</code> specifies the ordering of values.</p><p>If keys are analogous to array indices (linear or Cartesian), <a href="#QuickHeaps.FastPriorityQueue"><code>FastPriorityQueue</code></a> may provide a faster alternative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/192b5395cfcf7dcb5ae15262933de6450cacb998/src/priorityqueues.jl#L3-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.FastPriorityQueue" href="#QuickHeaps.FastPriorityQueue"><code>QuickHeaps.FastPriorityQueue</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FastPriorityQueue{V}(o=TotalMin, dims...)</code></pre><p>yields a priority queue for keys analogous of indices in an array of size <code>dims...</code> and priority values of type <code>V</code>. Optional argument <code>o::Ordering</code> specifies the ordering of values. The keys are stored as linear indices of type <code>Int</code>.</p><p>See <a href="#QuickHeaps.PriorityQueue"><code>PriorityQueue</code></a> if keys cannot be assumed to be array indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/192b5395cfcf7dcb5ae15262933de6450cacb998/src/priorityqueues.jl#L17-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataStructures.dequeue!-Tuple{AbstractPriorityQueue}" href="#DataStructures.dequeue!-Tuple{AbstractPriorityQueue}"><code>DataStructures.dequeue!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dequeue!(pq) -&gt; key</code></pre><p>Remove the root entry from the priority queue <code>pq</code> and return its key.</p><p>You may call <a href="#DataStructures.dequeue_pair!"><code>dequeue_pair!(pq)</code></a> to dequeue the root entry as a key-value pair.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/192b5395cfcf7dcb5ae15262933de6450cacb998/src/priorityqueues.jl#L134-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataStructures.dequeue_pair!" href="#DataStructures.dequeue_pair!"><code>DataStructures.dequeue_pair!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dequeue_pair!(pq) -&gt; (key =&gt; val)</code></pre><p>Remove the root entry from the priority queue <code>pq</code> and return it as a key-value pair. This is the same as <code>pop!(pq)</code>.</p><p>Also see <a href="#DataStructures.dequeue!-Tuple{AbstractPriorityQueue}"><code>dequeue!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/192b5395cfcf7dcb5ae15262933de6450cacb998/src/priorityqueues.jl#L145-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataStructures.enqueue!-Tuple{AbstractPriorityQueue, Any, Any}" href="#DataStructures.enqueue!-Tuple{AbstractPriorityQueue, Any, Any}"><code>DataStructures.enqueue!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pq[key...] = val
setindex!(pq, val, key...) -&gt; pq
enqueue!(pq, key, val) -&gt; pq
enqueue!(pq, key =&gt; val) -&gt; pq
push!(pq, key =&gt; val) -&gt; pq</code></pre><p>Set the value <code>val</code> stored by the priority queue <code>pq</code> at index <code>key</code> automatically maintaining the partial ordering of <code>pq</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/192b5395cfcf7dcb5ae15262933de6450cacb998/src/priorityqueues.jl#L210-L220">source</a></section></article><h2 id="Orderings"><a class="docs-heading-anchor" href="#Orderings">Orderings</a><a id="Orderings-1"></a><a class="docs-heading-anchor-permalink" href="#Orderings" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.FastMin" href="#QuickHeaps.FastMin"><code>QuickHeaps.FastMin</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.FastMinOrdering &lt;: Base.Order.Ordering
const FastMin = QuickHeaps.FastMinOrdering()</code></pre><p>Singleton for <em>min ordering</em>. This ordering is faster than <a href="#QuickHeaps.TotalMin"><code>TotalMin</code></a> but leaves indefinite the order of <code>NaN</code> values.</p><p><code>QuickHeaps.FastMinOrdering</code> is the type of <code>FastMin</code>.</p><p>Also see <a href="#QuickHeaps.FastMax"><code>FastMax</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/192b5395cfcf7dcb5ae15262933de6450cacb998/src/types.jl#L46-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.FastMax" href="#QuickHeaps.FastMax"><code>QuickHeaps.FastMax</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">FastMax</code></pre><p>Singleton for <em>max ordering</em>. This ordering is faster than <a href="#QuickHeaps.TotalMax"><code>TotalMax</code></a> but leaves indefinite the order of <code>NaN</code> values.</p><p><code>QuickHeaps.FastMaxOrdering</code> is an alias to the type of <code>FastMax</code>.</p><p>Also see <a href="#QuickHeaps.FastMin"><code>FastMin</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/192b5395cfcf7dcb5ae15262933de6450cacb998/src/types.jl#L61-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.TotalMin" href="#QuickHeaps.TotalMin"><code>QuickHeaps.TotalMin</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">TotalMin</code></pre><p>Singleton for <em>total min ordering</em> considering NaN&#39;s as greater than any other floating-point value, and <code>missing</code> to be greater than anything else. With this ordering, values are sorted in ascending order, followed by <code>NaN</code> then <code>missing</code> values.</p><p><code>TotalMin</code> is similar to the default ordering in most Julia algorithms and which is implemented by <code>isless</code>. However, for arrays of floating-point values with 50% of NaN&#39;s, <code>TotalMin</code> is nearly as fast as (19%) using <code>&lt;</code> and is almost twice faster (82%) than <code>isless</code>. This speed-up is obtained by using non-branching bitwise operators instead of logical operators.</p><p><code>QuickHeaps.TotalMinOrdering</code> is the type of <code>TotalMin</code>.</p><p>Also see <a href="#QuickHeaps.TotalMax"><code>TotalMax</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/192b5395cfcf7dcb5ae15262933de6450cacb998/src/types.jl#L7-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.TotalMax" href="#QuickHeaps.TotalMax"><code>QuickHeaps.TotalMax</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">TotalMax</code></pre><p>Singleton for <em>total max ordering</em>. With this ordering, values are sorted in decreasing order, followed by <code>NaN</code> then <code>missing</code> values.</p><p><code>QuickHeaps.TotalMaxOrdering</code> is the type of <code>TotalMax</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>TotalMax</code> and <code>reverse(TotalMin)</code> both sort regular values in decreasing order but the latter puts <code>missing</code> then <code>NaN</code> values <em>first</em>.</p></div></div><p>Also see <a href="#QuickHeaps.TotalMin"><code>TotalMin</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/192b5395cfcf7dcb5ae15262933de6450cacb998/src/types.jl#L28-L42">source</a></section></article><h2 id="Miscellaneous"><a class="docs-heading-anchor" href="#Miscellaneous">Miscellaneous</a><a id="Miscellaneous-1"></a><a class="docs-heading-anchor-permalink" href="#Miscellaneous" title="Permalink"></a></h2><p>The following non-exported methods may be needed for implementing new types of binary heap or of priority queue. End-users probably not have to worry about these.</p><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.has_bad_values" href="#QuickHeaps.has_bad_values"><code>QuickHeaps.has_bad_values</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.has_bad_values(A[, isbad])</code></pre><p>yields whether array <code>A</code> has bad values according to predicate <code>isbad</code>. For arrays with floating-point values, <code>isbad</code> default to <code>isnan</code> if unspecified. For integer-valued arrays, this function always returns <code>false</code> if <code>isnan</code> is unspecified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/192b5395cfcf7dcb5ae15262933de6450cacb998/src/utilities.jl#L66-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.heap_index" href="#QuickHeaps.heap_index"><code>QuickHeaps.heap_index</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.heap_index(pq, key) -&gt; i::Int</code></pre><p>Return the index <code>i</code> corresponding to <code>key</code> in the binary heap backing the storage of the entries of the priority queue <code>pq</code>. If the <code>key</code> is not in priority queue, <code>i = 0</code> is returned, otherwise <code>i ∈ 1:n</code> with <code>n = length(pq)</code> is returned.</p><p>The <code>heap_index</code> method is used to implement <code>haskey</code>, <code>get</code>, and <code>delete!</code> methods for priority queues. The <code>heap_index</code> method shall be specialized for any concrete sub-types of <code>QuickHeaps.AbstractPriorityQueue</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/192b5395cfcf7dcb5ae15262933de6450cacb998/src/priorityqueues.jl#L335-L346">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.storage" href="#QuickHeaps.storage"><code>QuickHeaps.storage</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.storage(h)</code></pre><p>yields the array backing the storage of the values in the binary heap <code>h</code>.</p><p>This method may be specialized for custom binary heap types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/192b5395cfcf7dcb5ae15262933de6450cacb998/src/binaryheaps.jl#L44-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.setroot!" href="#QuickHeaps.setroot!"><code>QuickHeaps.setroot!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setroot!(h, x) -&gt; h</code></pre><p>replaces the value of the root note in heap <code>h</code> by <code>x</code>. This is similar to <code>h[1] = x</code> but a bit faster.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/192b5395cfcf7dcb5ae15262933de6450cacb998/src/binaryheaps.jl#L148-L154">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../customize/">« Custom order</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 1 October 2025 13:15">Wednesday 1 October 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
