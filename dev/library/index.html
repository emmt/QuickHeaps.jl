<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · Efficient and versatile binary heaps and priority queues for Julia</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Efficient and versatile binary heaps and priority queues for Julia</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../install/">Installation</a></li><li><a class="tocitem" href="../binaryheaps/">Binary heaps</a></li><li><a class="tocitem" href="../priorityqueues/">Priority queues</a></li><li><a class="tocitem" href="../nodes/">Nodes types</a></li><li><a class="tocitem" href="../customize/">-</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Binary-Heaps"><span>Binary Heaps</span></a></li><li><a class="tocitem" href="#Priority-Queues"><span>Priority Queues</span></a></li><li><a class="tocitem" href="#Nodes"><span>Nodes</span></a></li><li><a class="tocitem" href="#Orderings"><span>Orderings</span></a></li><li><a class="tocitem" href="#Miscellaneous"><span>Miscellaneous</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/emmt/QuickHeaps.jl/blob/master/docs/src/library.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><p>The following reproduces the in-lined documentation about types and methods of the <a href="https://github.com/emmt/QuickHeaps.jl"><code>QuickHeaps</code></a> package. This documentation is also available from the REPL by typing <code>?</code> followed by the name of a method or a type.</p><h2 id="Binary-Heaps"><a class="docs-heading-anchor" href="#Binary-Heaps">Binary Heaps</a><a id="Binary-Heaps-1"></a><a class="docs-heading-anchor-permalink" href="#Binary-Heaps" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.AbstractBinaryHeap" href="#QuickHeaps.AbstractBinaryHeap"><code>QuickHeaps.AbstractBinaryHeap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.AbstractBinaryHeap{T,O}</code></pre><p>is the super-type of binary heaps in <code>QuickHeaps</code> whose values have type <code>T</code> and whose ordering has type <code>O</code>.</p><p>The following methods are available for a binary heap <code>h</code> (those which modify the heap contents re-order heap values as needed to maintain the heap structure):</p><pre><code class="nohighlight hljs">pop!(h)        # deletes and returns root value of heap h
push!(h, x)    # pushes value x in heap h
empty!(h)      # empties heap h
isempty(h)     # yields whether heap h is empty
delete!(h, i)  # deletes i-th value from heap h
peek(h)        # yields root value of heap h without deleting it
first(h)       # idem
setroot!(h, x) # same as h[1] = x, replaces root value of heap h by x</code></pre><p>A binary heap <code>h</code> behaves like an abstract vector (with 1-based linear indices), in particular:</p><pre><code class="nohighlight hljs">length(h)   # the number of values in heap h
h[i]        # the i-th value of heap h
h[i] = x    # set the i-th value of heap h and heapify h</code></pre><p>Note that <code>h[1]</code> is the root value of the heap <code>h</code> and that setting a value in the heap may trigger reordering of the values to maintain the binary heap structure. In other words, after doing <code>h[i] = x</code>, do not assume that <code>h[i]</code> yields <code>x</code>.</p><p>Operations that modify the heap, like deletion by <code>delete!(h,i)</code>, insertion by <code>h[i] = x</code>, pushing by <code>push!(h,x)</code>, and extracting by <code>pop!(h)</code> are of complexity <code>O(1)</code> in the best case, <code>O(log(n))</code> in the worst case, with <code>n = length(h)</code> the number of values in the heap <code>h</code>. Retrieving a given value with <code>peek(h)</code>, <code>first(h)</code>, or <code>h[i]</code> is always of complexity <code>O(1)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/types.jl#L96-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.BinaryHeap" href="#QuickHeaps.BinaryHeap"><code>QuickHeaps.BinaryHeap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">h = BinaryHeap{T}([o::Base.Order.Ordering = TotalMin,][ vals::AbstractVector])</code></pre><p>Build an empty binary heap whose values have type <code>T</code> and with ordering specified by <code>o</code>.</p><p>The method <a href="#QuickHeaps.lt"><code>QuickHeaps.lt(o,x::T,y::T)</code></a> is called to determine the order of values <code>x</code> and <code>y</code> in the heap. The default ordering, <a href="#QuickHeaps.TotalMin"><code>TotalMin</code></a>, yields a <em>min-heap</em> object; with <a href="#QuickHeaps.TotalMax"><code>TotalMax</code></a> ordering, a <em>max-heap</em> object is returned.</p><p>An optional vector <code>vals</code> storing the initial values of the binary heap can be specified. These values in <code>vals</code> need not be ordered, the <code>BinaryHeap</code> constructor automatically takes care of that. If <code>vals</code> is a <code>Vector{T}</code> instance, the binary-heap will be directly built into <code>vals</code>. Call <code>BinaryHeap(copy(vals))</code> to create a binary heap with its own storage.</p><p>Arguments <code>o</code> and <code>vals</code> may be specified in any order.</p><p>Method <code>sizehint!(h,n)</code> may be called to anticipate that the heap may contains <code>n</code> values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/binaryheaps.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.FastBinaryHeap" href="#QuickHeaps.FastBinaryHeap"><code>QuickHeaps.FastBinaryHeap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">h = FastBinaryHeap{T}([o::Base.Order.Ordering = TotalMin,][ vals::AbstractVector])</code></pre><p>Build a fast binary heap. Compared to <a href="#QuickHeaps.BinaryHeap"><code>BinaryHeap{T}(...)</code></a>, the array backing the storage of the heap values is never automatically reduced to improve performances in some cases. You may call <code>resize!(h)</code> to explicitly reduce the storage of fast binary-heap <code>h</code> to its minimum.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/binaryheaps.jl#L21-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.heapify" href="#QuickHeaps.heapify"><code>QuickHeaps.heapify</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">heapify([o=TotalMin,] A, n=length(A))</code></pre><p>yields an array with the <code>n</code> first values of array <code>A</code> stored in a binary heap structure of ordering specified by <code>o</code>. The storage of the returned heap is a different array than <code>A</code>. Arguments may be specified in any order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/binaryheaps.jl#L251-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.heapify!" href="#QuickHeaps.heapify!"><code>QuickHeaps.heapify!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">heapify!(h) -&gt; h</code></pre><p>reorders the values in the binary heap <code>h</code> in-place. This method should be called to initialize the heap or to re-order the heap if its contents have been modified by other methods than <code>pop!</code> or <code>push!</code>.</p><p>The method can be called at a lower level to heapify (part of) an array storing the heap values:</p><pre><code class="nohighlight hljs">heapify!([o=TotalMin,] A, n=length(A)) -&gt; A</code></pre><p>reorders the <code>n</code> first elements of array <code>A</code> in-place to form a binary heap according to the ordering specified by <code>o</code>. The array <code>A</code> must have 1-based linear indexing. Arguments may be specified in any order.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/binaryheaps.jl#L218-L234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.heapify_down!" href="#QuickHeaps.heapify_down!"><code>QuickHeaps.heapify_down!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.heapify_down!(o, A, i, x=A[i], n=lengh(A)) -&gt; A</code></pre><p>stores the value <code>x</code> in the <code>i</code>-th entry of the binary heap built into the <code>n</code> first elements of array <code>A</code> with ordering <code>o</code> and, if needed, moves down the inserted value to maintain the binary heap structure.</p><p>This method is called to <em>heapify</em> an array in order to initialize or rebuild the heap structure or to replace the value of the root value of the heap and update the heap structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/binaryheaps.jl#L314-L325">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.heapify_up!" href="#QuickHeaps.heapify_up!"><code>QuickHeaps.heapify_up!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>QuickHeaps.heapify_up!(o, A, i, x=A[i]) -&gt; A</p><p>stores the value <code>x</code> in the <code>i</code>-th entry of the binary heap built into the <code>i</code> first elements of array <code>A</code> with ordering <code>o</code> and, if needed, moves up the value to maintain the heap structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/binaryheaps.jl#L363-L370">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.isheap" href="#QuickHeaps.isheap"><code>QuickHeaps.isheap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isheap([o=TotalMin,], A, n=length(A))</code></pre><p>yields whether the <code>n</code> first elements of array <code>A</code> have a binary heap structure ordered as specified by <code>o</code>. Arguments may be specified in any order.</p><pre><code class="nohighlight hljs">isheap(obj; check=false)</code></pre><p>yields whether object <code>obj</code> is a binary heap. If keyword <code>check</code> is true, the internal structure of <code>obj</code> is checked; otherwise, the type of <code>obj</code> is trusted to determine whether it is a binary heap.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/binaryheaps.jl#L264-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.unsafe_heapify_down!" href="#QuickHeaps.unsafe_heapify_down!"><code>QuickHeaps.unsafe_heapify_down!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.unsafe_heapify_down!(o, A, i, x=A[i], n=lengh(A))</code></pre><p>This method is a fast but <em>unsafe</em> version of <a href="#QuickHeaps.heapify_down!"><code>QuickHeaps.heapify_down!</code></a> which assumes that all arguments are correct, that is <code>A</code> implements 1-based linear indexing, <code>0 ≤ n ≤ lengh(A)</code>, and <code>1 ≤ i ≤ n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/binaryheaps.jl#L339-L346">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.unsafe_heapify_up!" href="#QuickHeaps.unsafe_heapify_up!"><code>QuickHeaps.unsafe_heapify_up!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.unsafe_heapify_up!(o, A, i, x=A[i])</code></pre><p>This methods is a fast but <em>unsafe</em> version of <a href="#QuickHeaps.heapify_up!"><code>QuickHeaps.heapify_up!</code></a> which assumes that all arguments are correct, that is <code>A</code> implements 1-based linear indexing and <code>1 ≤ i ≤ length(A)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/binaryheaps.jl#L383-L390">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.unsafe_grow!" href="#QuickHeaps.unsafe_grow!"><code>QuickHeaps.unsafe_grow!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.unsafe_grow!(h, n) -&gt; A</code></pre><p>grows the size of the binary heap <code>h</code> to be <code>n</code> and returns the array <code>A</code> backing the storage of the values. This method is <em>unsafe</em> because it does not check its arguments and because it breaks the binary heap structure of the array of values.</p><p>This method is called by <code>push!</code> to grow the size of the heap and shall be specialized for any concrete sub-types of <code>QuickHeaps.AbstractBinaryHeap</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/binaryheaps.jl#L186-L196">source</a></section><section><div><pre><code class="nohighlight hljs">QuickHeaps.unsafe_grow!(pq, n) -&gt; pq</code></pre><p>grows the size of the binary heap backing the storage of the nodes of the priority queue <code>pq</code> to be <code>n</code> and returns the priority queue object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/priorityqueues.jl#L518-L524">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.unsafe_shrink!" href="#QuickHeaps.unsafe_shrink!"><code>QuickHeaps.unsafe_shrink!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.unsafe_shrink!(h, n)</code></pre><p>shrinks the size of the binary heap <code>h</code> to be <code>n</code>. This method is <em>unsafe</em> because it does not check its arguments.</p><p>This method is called by <code>delete!</code> to eventually reduce the size of the heap and shall be specialized for any concrete sub-type of <a href="#QuickHeaps.AbstractBinaryHeap"><code>QuickHeaps.AbstractBinaryHeap</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/binaryheaps.jl#L205-L214">source</a></section><section><div><pre><code class="nohighlight hljs">QuickHeaps.unsafe_shrink!(pq, n)</code></pre><p>shrinks the size of the binary heap backing the storage of the nodes of the priority queue <code>pq</code> to be <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/priorityqueues.jl#L530-L536">source</a></section></article><h2 id="Priority-Queues"><a class="docs-heading-anchor" href="#Priority-Queues">Priority Queues</a><a id="Priority-Queues-1"></a><a class="docs-heading-anchor-permalink" href="#Priority-Queues" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.AbstractPriorityQueue" href="#QuickHeaps.AbstractPriorityQueue"><code>QuickHeaps.AbstractPriorityQueue</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.AbstractPriorityQueue{K,V,O}</code></pre><p>is the super type of priority queues with ordering of type <code>O&lt;:Base.Order.Ordering</code> and storing nodes associating a key of type <code>K</code> with a priority value of type <code>V</code>.</p><p>Package <code>QuickHeaps</code> provides two concrete types of priority queues: <a href="#QuickHeaps.PriorityQueue"><code>PriorityQueue</code></a> for any kind of keys and <a href="#QuickHeaps.FastPriorityQueue"><code>FastPriorityQueue</code></a> for which keys are analogous to array indices.</p><p>Priority queues behave like dictionaries with the additional feature of automatically maintaining an ordered structure according to the priority queue ordering and the node values. For a priority queue <code>pq</code>, retrieving the <em>root</em> node (i.e., the one of highest priority) without removing it costs <code>O(1)</code> and is done by:</p><pre><code class="nohighlight hljs">peek(pq, T=Pair) -&gt; T(key, val)</code></pre><p>with <code>T</code> the type of the expected result. Retrieving the value of a node given its <code>key</code> has also an <code>O(1)</code> complexity and is done by one of:</p><pre><code class="nohighlight hljs">pq[key...] -&gt; val
getindex(pq, key...) -&gt; val
get(pq, key, def) -&gt; val_at_key_or_def</code></pre><p>Changing the content of the priority queue has a complexity of <code>O(log(n))</code> with <code>n = length(pq)</code> the number of nodes in the queue. This includes removing the node at <code>key</code> by:</p><pre><code class="nohighlight hljs">delete!(pq, key) -&gt; pq</code></pre><p>or removing the root node by:</p><pre><code class="nohighlight hljs">pop!(pq)          # -&gt; root node as a `key=&gt;val` pair
dequeue!(pq)      # -&gt; key of root node
dequeue_pair!(pq) # -&gt; root node as a `key=&gt;val` pair
dequeue_node!(pq) # -&gt; root node as stored in priority queue</code></pre><p>or setting a node <code>x</code> with a given <code>key</code> and value <code>val</code> by one of:</p><pre><code class="nohighlight hljs">pq[key] = val
enqueue!(pq, key, val)
enqueue!(pq, key =&gt; val)
push!(pq, key =&gt; val)
push!(pq, (key, val))
push!(pq, x) # x is a node with a key and a value</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/types.jl#L153-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.PriorityQueue" href="#QuickHeaps.PriorityQueue"><code>QuickHeaps.PriorityQueue</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PriorityQueue{K,V}([o=TotalMin,] T=Node{K,V})</code></pre><p>yields a priority queue for keys of type <code>K</code> and priority values of type <code>V</code>. Optional arguments <code>o::Ordering</code> and <code>T&lt;:AbstractNode{K,V}</code> are to specify the ordering of values and type of nodes to store key-value pairs. Type parameters <code>K</code> and <code>V</code> may be omitted if the node type <code>T</code> is specified.</p><p>Having a specific node type may be useful to specialize the <code>QuickHeaps.lt</code> method which is called to determine the order.</p><p>If keys are analogous to array indices (linear or Cartesian), <a href="#QuickHeaps.FastPriorityQueue"><code>FastPriorityQueue</code></a> may provide a faster alternative.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/priorityqueues.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.FastPriorityQueue" href="#QuickHeaps.FastPriorityQueue"><code>QuickHeaps.FastPriorityQueue</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FastPriorityQueue{V}([o=TotalMin,] [T=Node{Int,V},] dims...)</code></pre><p>yields a priority queue for keys analogous of indices in an array of size <code>dims...</code> and priority values of type <code>V</code>. Optional arguments <code>o::Ordering</code> and <code>T&lt;:AbstractNode{Int,V}</code> are to specify the ordering of values and type of nodes to store key-value pairs (the key is stored as a linear index of type <code>Int</code>). Type parameter <code>V</code> may be omitted if the node type <code>T</code> is specified.</p><p>See <a href="#QuickHeaps.PriorityQueue"><code>PriorityQueue</code></a> if keys cannot be assumed to be array indices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/priorityqueues.jl#L39-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataStructures.dequeue!-Tuple{AbstractPriorityQueue}" href="#DataStructures.dequeue!-Tuple{AbstractPriorityQueue}"><code>DataStructures.dequeue!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dequeue!(pq) -&gt; key</code></pre><p>Remove the root node from the priority queue <code>pq</code> and return its key.</p><p>You may call<em>node!(pq)`](@ref dequeue</em>node!) or <a href="#DataStructures.dequeue_pair!"><code>dequeue_pair!(pq)</code></a> to dequeue the root node as stored in <code>pq</code> or as a key-value pair.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/priorityqueues.jl#L237-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.dequeue_node!" href="#QuickHeaps.dequeue_node!"><code>QuickHeaps.dequeue_node!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dequeue_node!(pq) -&gt; node</code></pre><p>Removes and return the root node from the priority queue <code>pq</code>.</p><p>Also see <a href="#DataStructures.dequeue!-Tuple{AbstractPriorityQueue}"><code>dequeue!</code></a> and <a href="#DataStructures.dequeue_pair!"><code>dequeue_pair!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/priorityqueues.jl#L248-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataStructures.dequeue_pair!" href="#DataStructures.dequeue_pair!"><code>DataStructures.dequeue_pair!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dequeue_pair!(pq) -&gt; (key =&gt; val)</code></pre><p>removes the root node from the priority queue <code>pq</code> and returns it as a key-value <code>Pair</code>. This is the same as <code>pop!(pq)</code>.</p><p>Also see <a href="#DataStructures.dequeue!-Tuple{AbstractPriorityQueue}"><code>dequeue!</code></a> and <a href="#QuickHeaps.dequeue_node!"><code>dequeue_node!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/priorityqueues.jl#L273-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataStructures.enqueue!-Tuple{AbstractPriorityQueue, Any, Any}" href="#DataStructures.enqueue!-Tuple{AbstractPriorityQueue, Any, Any}"><code>DataStructures.enqueue!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pq[key...] = val
setindex!(pq, val, key...) -&gt; pq
enqueue!(pq, key, val) -&gt; pq
enqueue!(pq, key=&gt;val) -&gt; pq
push!(pq, key=&gt;val) -&gt; pq</code></pre><p>Set the value <code>val</code> stored by the priority queue <code>pq</code> at index <code>key</code> automatically maintaining the partial ordering of <code>pq</code>.</p><p>If <code>x</code> is an object which has a key and a value retrievable by <a href="#QuickHeaps.get_key"><code>QuickHeaps.get_key(x)</code></a> and <a href="#QuickHeaps.get_val"><code>QuickHeaps.get_val(x)</code></a>, then the following calls are other possibilities:</p><pre><code class="nohighlight hljs">enqueue!(pq, x) -&gt; pq
push!(pq, x) -&gt; pq</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/priorityqueues.jl#L441-L458">source</a></section></article><h2 id="Nodes"><a class="docs-heading-anchor" href="#Nodes">Nodes</a><a id="Nodes-1"></a><a class="docs-heading-anchor-permalink" href="#Nodes" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.AbstractNode" href="#QuickHeaps.AbstractNode"><code>QuickHeaps.AbstractNode</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.AbstractNode{K,V}</code></pre><p>is the super-type of nodes with a key of type <code>K</code> and a value of type <code>V</code>. Nodes can be used in binary heaps and priority queues to represent key-value pairs and specific ordering rules may be imposed by specializing the <code>QuickHeaps.lt</code> function which, for abstract nodes, is by default:</p><pre><code class="nohighlight hljs">QuickHeaps.lt(o::Base.Order.Ordering, x::T, y::T) where {T&lt;:QuickHeaps.AbstractNode} =
    Base.Order.lt(o, QuickHeaps.get_val(x), QuickHeaps.get_val(y))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/types.jl#L76-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.Node" href="#QuickHeaps.Node"><code>QuickHeaps.Node</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.Node{K=typeof(k),V=typeof(v)}(k,v)</code></pre><p>yields a node storing key <code>k</code> and value <code>v</code>. Optional type parameters <code>K</code> and <code>V</code> are the respective types of the key and of the value.</p><p>See also <a href="#QuickHeaps.AbstractNode"><code>QuickHeaps.AbstractNode</code></a>, <a href="#QuickHeaps.AbstractPriorityQueue"><code>QuickHeaps.AbstractPriorityQueue</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/nodes.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.get_key" href="#QuickHeaps.get_key"><code>QuickHeaps.get_key</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.get_key(x::QuickHeaps.AbstractNode) -&gt; k</code></pre><p>yields the key <code>k</code> of node <code>x</code>. This method may be specialized for any sub-types of <a href="#QuickHeaps.AbstractNode"><code>QuickHeaps.AbstractNode</code></a>.</p><p>Also see <a href="#QuickHeaps.get_val"><code>QuickHeaps.get_val</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/nodes.jl#L14-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.get_val" href="#QuickHeaps.get_val"><code>QuickHeaps.get_val</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.get_val(x::QuickHeaps.AbstractNode) -&gt; v</code></pre><p>yields the value <code>v</code> of node <code>x</code>. This method may be specialized for any sub-types of <a href="#QuickHeaps.AbstractNode"><code>QuickHeaps.AbstractNode</code></a>.</p><p>Also see <a href="#QuickHeaps.get_key"><code>QuickHeaps.get_key</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/nodes.jl#L25-L33">source</a></section></article><h2 id="Orderings"><a class="docs-heading-anchor" href="#Orderings">Orderings</a><a id="Orderings-1"></a><a class="docs-heading-anchor-permalink" href="#Orderings" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.FastMin" href="#QuickHeaps.FastMin"><code>QuickHeaps.FastMin</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.FastMinOrdering &lt;: Base.Order.Ordering
const FastMin = QuickHeaps.FastMinOrdering()</code></pre><p>Singleton for <em>min ordering</em>. This ordering is faster than <a href="#QuickHeaps.TotalMin"><code>TotalMin</code></a> but leaves indefinite the order of <code>NaN</code> values.</p><p><code>QuickHeaps.FastMinOrdering</code> is the type of <code>FastMin</code>.</p><p>Also see <a href="#QuickHeaps.FastMax"><code>FastMax</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/types.jl#L46-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.FastMax" href="#QuickHeaps.FastMax"><code>QuickHeaps.FastMax</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">FastMax</code></pre><p>Singleton for <em>max ordering</em>. This ordering is faster than <a href="#QuickHeaps.TotalMax"><code>TotalMax</code></a> but leaves indefinite the order of <code>NaN</code> values.</p><p><code>QuickHeaps.FastMaxOrdering</code> is an alias to the type of <code>FastMax</code>.</p><p>Also see <a href="#QuickHeaps.FastMin"><code>FastMin</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/types.jl#L61-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.TotalMin" href="#QuickHeaps.TotalMin"><code>QuickHeaps.TotalMin</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">TotalMin</code></pre><p>Singleton for <em>total min ordering</em> considering NaN&#39;s as greater than any other floating-point value, and <code>missing</code> to be greater than anything else. With this ordering, values are sorted in ascending order, followed by <code>NaN</code> then <code>missing</code> values.</p><p><code>TotalMin</code> is similar to the default ordering in most Julia algorithms and which is implemented by <code>isless</code>. However, for arrays of floating-point values with 50% of NaN&#39;s, <code>TotalMin</code> is nearly as fast as (19%) using <code>&lt;</code> and is almost twice faster (82%) than <code>isless</code>. This speed-up is obtained by using non-branching bitwise operators instead of logical operators.</p><p><code>QuickHeaps.TotalMinOrdering</code> is the type of <code>TotalMin</code>.</p><p>Also see <a href="#QuickHeaps.TotalMax"><code>TotalMax</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/types.jl#L7-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.TotalMax" href="#QuickHeaps.TotalMax"><code>QuickHeaps.TotalMax</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">TotalMax</code></pre><p>Singleton for <em>total max ordering</em>. With this ordering, values are sorted in decreasing order, followed by <code>NaN</code> then <code>missing</code> values.</p><p><code>QuickHeaps.TotalMaxOrdering</code> is the type of <code>TotalMax</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>TotalMax</code> and <code>reverse(TotalMin)</code> both sort regular values in decreasing order but the latter puts <code>missing</code> then <code>NaN</code> values <em>first</em>.</p></div></div><p>Also see <a href="#QuickHeaps.TotalMin"><code>TotalMin</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/types.jl#L28-L42">source</a></section></article><h2 id="Miscellaneous"><a class="docs-heading-anchor" href="#Miscellaneous">Miscellaneous</a><a id="Miscellaneous-1"></a><a class="docs-heading-anchor-permalink" href="#Miscellaneous" title="Permalink"></a></h2><p>The following non-exported methods may be needed for implementing new types of binary heap or of priority queue. End-users probably not have to worry about these.</p><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.has_bad_values" href="#QuickHeaps.has_bad_values"><code>QuickHeaps.has_bad_values</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.has_bad_values(A[, isbad])</code></pre><p>yields whether array <code>A</code> has bad values according to predicate <code>isbad</code>. For arrays with floating-point values, <code>isbad</code> default to <code>isnan</code> if unspecified. For integer-valued arrays, this function always returns <code>false</code> if <code>isnan</code> is unspecified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/utilities.jl#L108-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.has_standard_linear_indexing" href="#QuickHeaps.has_standard_linear_indexing"><code>QuickHeaps.has_standard_linear_indexing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.has_standard_linear_indexing(A)</code></pre><p>yields whether array <code>A</code> implements standard linear indexing (1-based).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/utilities.jl#L68-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.heap_index" href="#QuickHeaps.heap_index"><code>QuickHeaps.heap_index</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.heap_index(pq, key) -&gt; i::Int</code></pre><p>Return the index <code>i</code> corresponding to <code>key</code> in the binary heap backing the storage of the nodes of the priority queue <code>pq</code>. If the <code>key</code> is not in priority queue, <code>i = 0</code> is returned, otherwise <code>i ∈ 1:n</code> with <code>n = length(pq)</code> is returned.</p><p>The <code>heap_index</code> method is used to implement <code>haskey</code>, <code>get</code>, and <code>delete!</code> methods for priority queues. The <code>heap_index</code> method shall be specialized for any concrete sub-types of <code>QuickHeaps.AbstractPriorityQueue</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/priorityqueues.jl#L376-L387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.in_range" href="#QuickHeaps.in_range"><code>QuickHeaps.in_range</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.in_range(i, len::Integer)</code></pre><p>yields whether <code>1 ≤ i ≤ len</code>.</p><pre><code class="nohighlight hljs">QuickHeaps.in_range(i, A::Array)</code></pre><p>yields whether <code>i</code> is a valid linear index of array <code>A</code>.</p><pre><code class="nohighlight hljs">QuickHeaps.in_range(i, R::AbstractUnitRange{&lt;:Integer})</code></pre><p>yields whether <code>i</code> is in the range <code>R</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/utilities.jl#L89-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.is_one_based_unit_range" href="#QuickHeaps.is_one_based_unit_range"><code>QuickHeaps.is_one_based_unit_range</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.is_one_based_unit_range(itr)</code></pre><p>yields whether iterator <code>itr</code> is a 1-based unit range.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/utilities.jl#L78-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.linear_index" href="#QuickHeaps.linear_index"><code>QuickHeaps.linear_index</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.linear_index(pq, key) -&gt; k::Int</code></pre><p>Convert <code>key</code> into a linear index suitable for the fast priority queue <code>pq</code>. The <code>key</code> can be a linear index or a multi-dimensional index (anything accepted by <code>to_indices</code>). The current settings for bounds checking are used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/priorityqueues.jl#L410-L417">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.lt" href="#QuickHeaps.lt"><code>QuickHeaps.lt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.lt(o::Ordering, x::T, y::T)</code></pre><p>Return whether <code>x</code> is less than <code>y</code> according to ordering <code>o</code>.</p><p><code>QuickHeaps.lt</code> is called by <code>QuickHeaps</code> to build ordered structures like binary heaps and priority queues. For <code>T &lt;: QuickHeaps.AbstractNode</code>, <code>QuickHeaps.lt</code> compares the values of the nodes <code>x</code> and <code>y</code>; otherwise, <code>QuickHeaps.lt</code> calls <code>Base.Order.lt</code> to compare values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/utilities.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.nodes" href="#QuickHeaps.nodes"><code>QuickHeaps.nodes</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.nodes(pq)</code></pre><p>Yield the vector backing the storage of the nodes of priority queue <code>pq</code>. This vector has a binary-heap structure.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/priorityqueues.jl#L120-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.index" href="#QuickHeaps.index"><code>QuickHeaps.index</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.index(pq) -&gt; I</code></pre><p>Yield the <em>key to index</em> mapping of priority queue <code>pq</code> such that <code>I[key]</code> is the index of the node associated with <code>key</code> in the binary heap <code>QuickHeaps.nodes(pq)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/priorityqueues.jl#L111-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.storage" href="#QuickHeaps.storage"><code>QuickHeaps.storage</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.storage(h)</code></pre><p>yields the array backing the storage of the values in the binary heap <code>h</code>.</p><p>This method may be specialized for custom binary heap types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/binaryheaps.jl#L42-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.ordering" href="#QuickHeaps.ordering"><code>QuickHeaps.ordering</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.ordering(A) -&gt; o</code></pre><p>Return the object <code>o</code> specifying the ordering of the values in the object <code>A</code>, a binary heap or a priority queue.</p><p>This method may be specialized for custom types.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/utilities.jl#L41-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.setroot!" href="#QuickHeaps.setroot!"><code>QuickHeaps.setroot!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setroot!(h, x) -&gt; h</code></pre><p>replaces the value of the root note in heap <code>h</code> by <code>x</code>. This is similar to <code>h[1] = x</code> but a bit faster.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/binaryheaps.jl#L144-L150">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.to_key" href="#QuickHeaps.to_key"><code>QuickHeaps.to_key</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.to_key(pq, key)</code></pre><p>Convert <code>key</code> to the type of keys used by the priority queue <code>pq</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/priorityqueues.jl#L334-L339">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.to_node" href="#QuickHeaps.to_node"><code>QuickHeaps.to_node</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.to_node(pq, key =&gt; val)
QuickHeaps.to_node(pq, key, val)</code></pre><p>Convert the association of <code>key</code> and value <code>val</code> into a node of the type stored by the priority queue <code>pq</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/priorityqueues.jl#L352-L359">source</a></section><section><div><pre><code class="nohighlight hljs">QuickHeaps.to_node(pq, x)</code></pre><p>Convert <code>x</code> into a node of the type stored by the priority queue <code>pq</code>. Methods <a href="#QuickHeaps.get_key"><code>QuickHeaps.get_key(x)</code></a> and <a href="#QuickHeaps.get_val"><code>QuickHeaps.get_val(x)</code></a> must be implemented for object <code>x</code>,</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/priorityqueues.jl#L366-L373">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.to_val" href="#QuickHeaps.to_val"><code>QuickHeaps.to_val</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.to_val(pq, val)</code></pre><p>Convert value <code>val</code> to the type of values stored by the priority queue <code>pq</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/priorityqueues.jl#L343-L348">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="QuickHeaps.typename" href="#QuickHeaps.typename"><code>QuickHeaps.typename</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">QuickHeaps.typename(x)
QuickHeaps.typename(typeof(x))</code></pre><p>yield a short string describing the type of object <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/QuickHeaps.jl/blob/d97f8cf3f0e0a172b14a1776600a8150503f533d/src/utilities.jl#L126-L132">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../customize/">« -</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 3 September 2025 12:23">Wednesday 3 September 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
