var documenterSearchIndex = {"docs":
[{"location":"library/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"library/","page":"Reference","title":"Reference","text":"The following reproduces the in-lined documentation about types and methods of the QuickHeaps package. This documentation is also available from the REPL by typing ? followed by the name of a method or a type.","category":"page"},{"location":"library/#Binary-Heaps","page":"Reference","title":"Binary Heaps","text":"","category":"section"},{"location":"library/","page":"Reference","title":"Reference","text":"QuickHeaps.AbstractBinaryHeap\nQuickHeaps.BinaryHeap\nQuickHeaps.FastBinaryHeap\nQuickHeaps.heapify\nQuickHeaps.heapify!\nQuickHeaps.heapify_down!\nQuickHeaps.heapify_up!\nQuickHeaps.isheap\nQuickHeaps.unsafe_heapify_down!\nQuickHeaps.unsafe_heapify_up!\nQuickHeaps.unsafe_grow!\nQuickHeaps.unsafe_shrink!","category":"page"},{"location":"library/#QuickHeaps.AbstractBinaryHeap","page":"Reference","title":"QuickHeaps.AbstractBinaryHeap","text":"QuickHeaps.AbstractBinaryHeap{T,O}\n\nis the super-type of binary heaps in QuickHeaps whose values have type T and whose ordering has type O.\n\nThe following methods are available for a binary heap h (those which modify the heap contents re-order heap values as needed to maintain the heap structure):\n\npop!(h)        # deletes and returns root value of heap h\npush!(h, x)    # pushes value x in heap h\nempty!(h)      # empties heap h\nisempty(h)     # yields whether heap h is empty\ndelete!(h, i)  # deletes i-th value from heap h\npeek(h)        # yields root value of heap h without deleting it\nfirst(h)       # idem\nsetroot!(h, x) # same as h[1] = x, replaces root value of heap h by x\n\nA binary heap h behaves like an abstract vector (with 1-based linear indices), in particular:\n\nlength(h)   # the number of values in heap h\nh[i]        # the i-th value of heap h\nh[i] = x    # set the i-th value of heap h and heapify h\n\nNote that h[1] is the root value of the heap h and that setting a value in the heap may trigger reordering of the values to maintain the binary heap structure. In other words, after doing h[i] = x, do not assume that h[i] yields x.\n\nOperations that modify the heap, like deletion by delete!(h,i), insertion by h[i] = x, pushing by push!(h,x), and extracting by pop!(h) are of complexity O(1) in the best case, O(log(n)) in the worst case, with n = length(h) the number of values in the heap h. Retrieving a given value with peek(h), first(h), or h[i] is always of complexity O(1).\n\n\n\n\n\n","category":"type"},{"location":"library/#QuickHeaps.BinaryHeap","page":"Reference","title":"QuickHeaps.BinaryHeap","text":"h = BinaryHeap{T}([o::Base.Order.Ordering = TotalMin,][ vals::AbstractVector])\n\nBuild an empty binary heap whose values have type T and with ordering specified by o.\n\nThe method QuickHeaps.lt(o,x::T,y::T) is called to determine the order of values x and y in the heap. The default ordering, TotalMin, yields a min-heap object; with TotalMax ordering, a max-heap object is returned.\n\nAn optional vector vals storing the initial values of the binary heap can be specified. These values in vals need not be ordered, the BinaryHeap constructor automatically takes care of that. If vals is a Vector{T} instance, the binary-heap will be directly built into vals. Call BinaryHeap(copy(vals)) to create a binary heap with its own storage.\n\nArguments o and vals may be specified in any order.\n\nMethod sizehint!(h,n) may be called to anticipate that the heap may contains n values.\n\n\n\n\n\n","category":"type"},{"location":"library/#QuickHeaps.FastBinaryHeap","page":"Reference","title":"QuickHeaps.FastBinaryHeap","text":"h = FastBinaryHeap{T}([o::Base.Order.Ordering = TotalMin,][ vals::AbstractVector])\n\nBuild a fast binary heap. Compared to BinaryHeap{T}(...), the array backing the storage of the heap values is never automatically reduced to improve performances in some cases. You may call resize!(h) to explicitly reduce the storage of fast binary-heap h to its minimum.\n\n\n\n\n\n","category":"type"},{"location":"library/#QuickHeaps.heapify","page":"Reference","title":"QuickHeaps.heapify","text":"heapify([o=TotalMin,] A, n=length(A))\n\nyields an array with the n first values of array A stored in a binary heap structure of ordering specified by o. The storage of the returned heap is a different array than A. Arguments may be specified in any order.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.heapify!","page":"Reference","title":"QuickHeaps.heapify!","text":"heapify!(h) -> h\n\nreorders the values in the binary heap h in-place. This method should be called to initialize the heap or to re-order the heap if its contents have been modified by other methods than pop! or push!.\n\nThe method can be called at a lower level to heapify (part of) an array storing the heap values:\n\nheapify!([o=TotalMin,] A, n=length(A)) -> A\n\nreorders the n first elements of array A in-place to form a binary heap according to the ordering specified by o. The array A must have 1-based linear indexing. Arguments may be specified in any order.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.heapify_down!","page":"Reference","title":"QuickHeaps.heapify_down!","text":"QuickHeaps.heapify_down!(o, A, i, x=A[i], n=lengh(A)) -> A\n\nstores the value x in the i-th entry of the binary heap built into the n first elements of array A with ordering o and, if needed, moves down the inserted value to maintain the binary heap structure.\n\nThis method is called to heapify an array in order to initialize or rebuild the heap structure or to replace the value of the root value of the heap and update the heap structure.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.heapify_up!","page":"Reference","title":"QuickHeaps.heapify_up!","text":"QuickHeaps.heapify_up!(o, A, i, x=A[i]) -> A\n\nstores the value x in the i-th entry of the binary heap built into the i first elements of array A with ordering o and, if needed, moves up the value to maintain the heap structure.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.isheap","page":"Reference","title":"QuickHeaps.isheap","text":"isheap([o=TotalMin,], A, n=length(A))\n\nyields whether the n first elements of array A have a binary heap structure ordered as specified by o. Arguments may be specified in any order.\n\nisheap(obj; check=false)\n\nyields whether object obj is a binary heap. If keyword check is true, the internal structure of obj is checked; otherwise, the type of obj is trusted to determine whether it is a binary heap.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.unsafe_heapify_down!","page":"Reference","title":"QuickHeaps.unsafe_heapify_down!","text":"QuickHeaps.unsafe_heapify_down!(o, A, i, x=A[i], n=lengh(A))\n\nThis method is a fast but unsafe version of QuickHeaps.heapify_down! which assumes that all arguments are correct, that is A implements 1-based linear indexing, 0 ≤ n ≤ lengh(A), and 1 ≤ i ≤ n.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.unsafe_heapify_up!","page":"Reference","title":"QuickHeaps.unsafe_heapify_up!","text":"QuickHeaps.unsafe_heapify_up!(o, A, i, x=A[i])\n\nThis methods is a fast but unsafe version of QuickHeaps.heapify_up! which assumes that all arguments are correct, that is A implements 1-based linear indexing and 1 ≤ i ≤ length(A).\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.unsafe_grow!","page":"Reference","title":"QuickHeaps.unsafe_grow!","text":"QuickHeaps.unsafe_grow!(h, n) -> A\n\ngrows the size of the binary heap h to be n and returns the array A backing the storage of the values. This method is unsafe because it does not check its arguments and because it breaks the binary heap structure of the array of values.\n\nThis method is called by push! to grow the size of the heap and shall be specialized for any concrete sub-types of QuickHeaps.AbstractBinaryHeap.\n\n\n\n\n\nQuickHeaps.unsafe_grow!(pq, n) -> pq\n\ngrows the size of the binary heap backing the storage of the nodes of the priority queue pq to be n and returns the priority queue object.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.unsafe_shrink!","page":"Reference","title":"QuickHeaps.unsafe_shrink!","text":"QuickHeaps.unsafe_shrink!(h, n)\n\nshrinks the size of the binary heap h to be n. This method is unsafe because it does not check its arguments.\n\nThis method is called by delete! to eventually reduce the size of the heap and shall be specialized for any concrete sub-type of QuickHeaps.AbstractBinaryHeap.\n\n\n\n\n\nQuickHeaps.unsafe_shrink!(pq, n)\n\nshrinks the size of the binary heap backing the storage of the nodes of the priority queue pq to be n.\n\n\n\n\n\n","category":"function"},{"location":"library/#Priority-Queues","page":"Reference","title":"Priority Queues","text":"","category":"section"},{"location":"library/","page":"Reference","title":"Reference","text":"QuickHeaps.AbstractPriorityQueue\nQuickHeaps.PriorityQueue\nQuickHeaps.FastPriorityQueue\ndequeue!(::QuickHeaps.AbstractPriorityQueue)\ndequeue_node!\ndequeue_pair!\nenqueue!(::QuickHeaps.AbstractPriorityQueue, ::Any, ::Any)","category":"page"},{"location":"library/#QuickHeaps.AbstractPriorityQueue","page":"Reference","title":"QuickHeaps.AbstractPriorityQueue","text":"QuickHeaps.AbstractPriorityQueue{K,V,O}\n\nis the super type of priority queues with ordering of type O<:Base.Order.Ordering and storing nodes associating a key of type K with a priority value of type V.\n\nPackage QuickHeaps provides two concrete types of priority queues: PriorityQueue for any kind of keys and FastPriorityQueue for which keys are analogous to array indices.\n\nPriority queues behave like dictionaries with the additional feature of automatically maintaining an ordered structure according to the priority queue ordering and the node values. For a priority queue pq, retrieving the root node (i.e., the one of highest priority) without removing it costs O(1) and is done by:\n\npeek(pq, T=Pair) -> T(key, val)\n\nwith T the type of the expected result. Retrieving the value of a node given its key has also an O(1) complexity and is done by one of:\n\npq[key...] -> val\ngetindex(pq, key...) -> val\nget(pq, key, def) -> val_at_key_or_def\n\nChanging the content of the priority queue has a complexity of O(log(n)) with n = length(pq) the number of nodes in the queue. This includes removing the node at key by:\n\ndelete!(pq, key) -> pq\n\nor removing the root node by:\n\npop!(pq)          # -> root node as a `key=>val` pair\ndequeue!(pq)      # -> key of root node\ndequeue_pair!(pq) # -> root node as a `key=>val` pair\ndequeue_node!(pq) # -> root node as stored in priority queue\n\nor setting a node x with a given key and value val by one of:\n\npq[key] = val\nenqueue!(pq, key, val)\nenqueue!(pq, key => val)\npush!(pq, key => val)\npush!(pq, (key, val))\npush!(pq, x) # x is a node with a key and a value\n\n\n\n\n\n","category":"type"},{"location":"library/#QuickHeaps.PriorityQueue","page":"Reference","title":"QuickHeaps.PriorityQueue","text":"PriorityQueue{K,V}([o=TotalMin,] T=Node{K,V})\n\nyields a priority queue for keys of type K and priority values of type V. Optional arguments o::Ordering and T<:AbstractNode{K,V} are to specify the ordering of values and type of nodes to store key-value pairs. Type parameters K and V may be omitted if the node type T is specified.\n\nHaving a specific node type may be useful to specialize the QuickHeaps.lt method which is called to determine the order.\n\nIf keys are analogous to array indices (linear or Cartesian), FastPriorityQueue may provide a faster alternative.\n\n\n\n\n\n","category":"type"},{"location":"library/#QuickHeaps.FastPriorityQueue","page":"Reference","title":"QuickHeaps.FastPriorityQueue","text":"FastPriorityQueue{V}([o=TotalMin,] [T=Node{Int,V},] dims...)\n\nyields a priority queue for keys analogous of indices in an array of size dims... and priority values of type V. Optional arguments o::Ordering and T<:AbstractNode{Int,V} are to specify the ordering of values and type of nodes to store key-value pairs (the key is stored as a linear index of type Int). Type parameter V may be omitted if the node type T is specified.\n\nSee PriorityQueue if keys cannot be assumed to be array indices.\n\n\n\n\n\n","category":"type"},{"location":"library/#DataStructures.dequeue!-Tuple{AbstractPriorityQueue}","page":"Reference","title":"DataStructures.dequeue!","text":"dequeue!(pq) -> key\n\nRemove the root node from the priority queue pq and return its key.\n\nYou may callnode!(pq)`](@ref dequeuenode!) or dequeue_pair!(pq) to dequeue the root node as stored in pq or as a key-value pair.\n\n\n\n\n\n","category":"method"},{"location":"library/#QuickHeaps.dequeue_node!","page":"Reference","title":"QuickHeaps.dequeue_node!","text":"dequeue_node!(pq) -> node\n\nRemoves and return the root node from the priority queue pq.\n\nAlso see dequeue! and dequeue_pair!.\n\n\n\n\n\n","category":"function"},{"location":"library/#DataStructures.dequeue_pair!","page":"Reference","title":"DataStructures.dequeue_pair!","text":"dequeue_pair!(pq) -> (key => val)\n\nremoves the root node from the priority queue pq and returns it as a key-value Pair. This is the same as pop!(pq).\n\nAlso see dequeue! and dequeue_node!.\n\n\n\n\n\n","category":"function"},{"location":"library/#DataStructures.enqueue!-Tuple{AbstractPriorityQueue, Any, Any}","page":"Reference","title":"DataStructures.enqueue!","text":"pq[key...] = val\nsetindex!(pq, val, key...) -> pq\nenqueue!(pq, key, val) -> pq\nenqueue!(pq, key=>val) -> pq\npush!(pq, key=>val) -> pq\n\nSet the value val stored by the priority queue pq at index key automatically maintaining the partial ordering of pq.\n\nIf x is an object which has a key and a value retrievable by QuickHeaps.get_key(x) and QuickHeaps.get_val(x), then the following calls are other possibilities:\n\nenqueue!(pq, x) -> pq\npush!(pq, x) -> pq\n\n\n\n\n\n","category":"method"},{"location":"library/#Nodes","page":"Reference","title":"Nodes","text":"","category":"section"},{"location":"library/","page":"Reference","title":"Reference","text":"QuickHeaps.AbstractNode\nQuickHeaps.Node\nQuickHeaps.get_key\nQuickHeaps.get_val","category":"page"},{"location":"library/#QuickHeaps.AbstractNode","page":"Reference","title":"QuickHeaps.AbstractNode","text":"QuickHeaps.AbstractNode{K,V}\n\nis the super-type of nodes with a key of type K and a value of type V. Nodes can be used in binary heaps and priority queues to represent key-value pairs and specific ordering rules may be imposed by specializing the QuickHeaps.lt function which, for abstract nodes, is by default:\n\nQuickHeaps.lt(o::Base.Order.Ordering, x::T, y::T) where {T<:QuickHeaps.AbstractNode} =\n    Base.Order.lt(o, QuickHeaps.get_val(x), QuickHeaps.get_val(y))\n\n\n\n\n\n","category":"type"},{"location":"library/#QuickHeaps.Node","page":"Reference","title":"QuickHeaps.Node","text":"QuickHeaps.Node{K=typeof(k),V=typeof(v)}(k,v)\n\nyields a node storing key k and value v. Optional type parameters K and V are the respective types of the key and of the value.\n\nSee also QuickHeaps.AbstractNode, QuickHeaps.AbstractPriorityQueue.\n\n\n\n\n\n","category":"type"},{"location":"library/#QuickHeaps.get_key","page":"Reference","title":"QuickHeaps.get_key","text":"QuickHeaps.get_key(x::QuickHeaps.AbstractNode) -> k\n\nyields the key k of node x. This method may be specialized for any sub-types of QuickHeaps.AbstractNode.\n\nAlso see QuickHeaps.get_val.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.get_val","page":"Reference","title":"QuickHeaps.get_val","text":"QuickHeaps.get_val(x::QuickHeaps.AbstractNode) -> v\n\nyields the value v of node x. This method may be specialized for any sub-types of QuickHeaps.AbstractNode.\n\nAlso see QuickHeaps.get_key.\n\n\n\n\n\n","category":"function"},{"location":"library/#Orderings","page":"Reference","title":"Orderings","text":"","category":"section"},{"location":"library/","page":"Reference","title":"Reference","text":"QuickHeaps.FastMin\nQuickHeaps.FastMax\nQuickHeaps.TotalMin\nQuickHeaps.TotalMax","category":"page"},{"location":"library/#QuickHeaps.FastMin","page":"Reference","title":"QuickHeaps.FastMin","text":"QuickHeaps.FastMinOrdering <: Base.Order.Ordering\nconst FastMin = QuickHeaps.FastMinOrdering()\n\nSingleton for min ordering. This ordering is faster than TotalMin but leaves indefinite the order of NaN values.\n\nQuickHeaps.FastMinOrdering is the type of FastMin.\n\nAlso see FastMax.\n\n\n\n\n\n","category":"constant"},{"location":"library/#QuickHeaps.FastMax","page":"Reference","title":"QuickHeaps.FastMax","text":"FastMax\n\nSingleton for max ordering. This ordering is faster than TotalMax but leaves indefinite the order of NaN values.\n\nQuickHeaps.FastMaxOrdering is an alias to the type of FastMax.\n\nAlso see FastMin.\n\n\n\n\n\n","category":"constant"},{"location":"library/#QuickHeaps.TotalMin","page":"Reference","title":"QuickHeaps.TotalMin","text":"TotalMin\n\nSingleton for total min ordering considering NaN's as greater than any other floating-point value, and missing to be greater than anything else. With this ordering, values are sorted in ascending order, followed by NaN then missing values.\n\nTotalMin is similar to the default ordering in most Julia algorithms and which is implemented by isless. However, for arrays of floating-point values with 50% of NaN's, TotalMin is nearly as fast as (19%) using < and is almost twice faster (82%) than isless. This speed-up is obtained by using non-branching bitwise operators instead of logical operators.\n\nQuickHeaps.TotalMinOrdering is the type of TotalMin.\n\nAlso see TotalMax.\n\n\n\n\n\n","category":"constant"},{"location":"library/#QuickHeaps.TotalMax","page":"Reference","title":"QuickHeaps.TotalMax","text":"TotalMax\n\nSingleton for total max ordering. With this ordering, values are sorted in decreasing order, followed by NaN then missing values.\n\nQuickHeaps.TotalMaxOrdering is the type of TotalMax.\n\nnote: Note\nTotalMax and reverse(TotalMin) both sort regular values in decreasing order but the latter puts missing then NaN values first.\n\nAlso see TotalMin.\n\n\n\n\n\n","category":"constant"},{"location":"library/#Miscellaneous","page":"Reference","title":"Miscellaneous","text":"","category":"section"},{"location":"library/","page":"Reference","title":"Reference","text":"The following non-exported methods may be needed for implementing new types of binary heap or of priority queue. End-users probably not have to worry about these.","category":"page"},{"location":"library/","page":"Reference","title":"Reference","text":"QuickHeaps.has_bad_values\nQuickHeaps.has_standard_linear_indexing\nQuickHeaps.heap_index\nQuickHeaps.in_range\nQuickHeaps.is_one_based_unit_range\nQuickHeaps.linear_index\nQuickHeaps.lt\nQuickHeaps.nodes\nQuickHeaps.index\nQuickHeaps.storage\nQuickHeaps.ordering\nQuickHeaps.setroot!\nQuickHeaps.to_key\nQuickHeaps.to_node\nQuickHeaps.to_val\nQuickHeaps.typename","category":"page"},{"location":"library/#QuickHeaps.has_bad_values","page":"Reference","title":"QuickHeaps.has_bad_values","text":"QuickHeaps.has_bad_values(A[, isbad])\n\nyields whether array A has bad values according to predicate isbad. For arrays with floating-point values, isbad default to isnan if unspecified. For integer-valued arrays, this function always returns false if isnan is unspecified.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.has_standard_linear_indexing","page":"Reference","title":"QuickHeaps.has_standard_linear_indexing","text":"QuickHeaps.has_standard_linear_indexing(A)\n\nyields whether array A implements standard linear indexing (1-based).\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.heap_index","page":"Reference","title":"QuickHeaps.heap_index","text":"QuickHeaps.heap_index(pq, key) -> i::Int\n\nReturn the index i corresponding to key in the binary heap backing the storage of the nodes of the priority queue pq. If the key is not in priority queue, i = 0 is returned, otherwise i ∈ 1:n with n = length(pq) is returned.\n\nThe heap_index method is used to implement haskey, get, and delete! methods for priority queues. The heap_index method shall be specialized for any concrete sub-types of QuickHeaps.AbstractPriorityQueue.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.in_range","page":"Reference","title":"QuickHeaps.in_range","text":"QuickHeaps.in_range(i, len::Integer)\n\nyields whether 1 ≤ i ≤ len.\n\nQuickHeaps.in_range(i, A::Array)\n\nyields whether i is a valid linear index of array A.\n\nQuickHeaps.in_range(i, R::AbstractUnitRange{<:Integer})\n\nyields whether i is in the range R.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.is_one_based_unit_range","page":"Reference","title":"QuickHeaps.is_one_based_unit_range","text":"QuickHeaps.is_one_based_unit_range(itr)\n\nyields whether iterator itr is a 1-based unit range.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.linear_index","page":"Reference","title":"QuickHeaps.linear_index","text":"QuickHeaps.linear_index(pq, key) -> k::Int\n\nConvert key into a linear index suitable for the fast priority queue pq. The key can be a linear index or a multi-dimensional index (anything accepted by to_indices). The current settings for bounds checking are used.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.lt","page":"Reference","title":"QuickHeaps.lt","text":"QuickHeaps.lt(o::Ordering, x::T, y::T)\n\nReturn whether x is less than y according to ordering o.\n\nQuickHeaps.lt is called by QuickHeaps to build ordered structures like binary heaps and priority queues. For T <: QuickHeaps.AbstractNode, QuickHeaps.lt compares the values of the nodes x and y; otherwise, QuickHeaps.lt calls Base.Order.lt to compare values.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.nodes","page":"Reference","title":"QuickHeaps.nodes","text":"QuickHeaps.nodes(pq)\n\nYield the vector backing the storage of the nodes of priority queue pq. This vector has a binary-heap structure.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.index","page":"Reference","title":"QuickHeaps.index","text":"QuickHeaps.index(pq) -> I\n\nYield the key to index mapping of priority queue pq such that I[key] is the index of the node associated with key in the binary heap QuickHeaps.nodes(pq).\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.storage","page":"Reference","title":"QuickHeaps.storage","text":"QuickHeaps.storage(h)\n\nyields the array backing the storage of the values in the binary heap h.\n\nThis method may be specialized for custom binary heap types.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.ordering","page":"Reference","title":"QuickHeaps.ordering","text":"QuickHeaps.ordering(A) -> o\n\nReturn the object o specifying the ordering of the values in the object A, a binary heap or a priority queue.\n\nThis method may be specialized for custom types.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.setroot!","page":"Reference","title":"QuickHeaps.setroot!","text":"setroot!(h, x) -> h\n\nreplaces the value of the root note in heap h by x. This is similar to h[1] = x but a bit faster.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.to_key","page":"Reference","title":"QuickHeaps.to_key","text":"QuickHeaps.to_key(pq, key)\n\nConvert key to the type of keys used by the priority queue pq.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.to_node","page":"Reference","title":"QuickHeaps.to_node","text":"QuickHeaps.to_node(pq, key => val)\nQuickHeaps.to_node(pq, key, val)\n\nConvert the association of key and value val into a node of the type stored by the priority queue pq.\n\n\n\n\n\nQuickHeaps.to_node(pq, x)\n\nConvert x into a node of the type stored by the priority queue pq. Methods QuickHeaps.get_key(x) and QuickHeaps.get_val(x) must be implemented for object x,\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.to_val","page":"Reference","title":"QuickHeaps.to_val","text":"QuickHeaps.to_val(pq, val)\n\nConvert value val to the type of values stored by the priority queue pq.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.typename","page":"Reference","title":"QuickHeaps.typename","text":"QuickHeaps.typename(x)\nQuickHeaps.typename(typeof(x))\n\nyield a short string describing the type of object x.\n\n\n\n\n\n","category":"function"},{"location":"priorityqueues/#Priority-queues","page":"Priority queues","title":"Priority queues","text":"","category":"section"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"Priority queues are partially ordered dynamic lists of so-called nodes which are key-value pairs. Priority queues are designed so that updating the list of stored nodes while maintaining the ordering and retrieving or extracting the node of highest priority are efficient operations.","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"Priority queues provided by QuikHeaps are similar to dictionaries (or to arrays) with the additional feature of maintaining an ordered structure so that getting the node of highest priority costs O(1) operations while changing the priority of a node or pushing a node only costs O(log(n)) operations with n the length of the queue.","category":"page"},{"location":"priorityqueues/#Building-priority-queues","page":"Priority queues","title":"Building priority queues","text":"","category":"section"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"In QuikHeaps, priority queues combine a binary heap to store the partially sorted list of nodes and another structure to associate keys and nodes. There are two possibilities depending on the kind of keys.","category":"page"},{"location":"priorityqueues/#Versatile-priority-queues","page":"Priority queues","title":"Versatile priority queues","text":"","category":"section"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"QuikHeaps provides versatile priority queues which use a dictionary to associate keys with nodes and thus impose no restrictions on the type of the keys. To build a versatile priority queue, call the PriorityQueue constructor:","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"Q = PriorityQueue{K,V}([o=TotalMin,] T=Node{K,V})","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"where optional parameter o::Ordering specifies the ordering for deciding the priority of values while optional parameter T<:AbstractNode{K,V} specifies the type of the nodes with K and V the respective types of the keys and of the values. Type parameters K and V may be omitted if the node type T is specified.","category":"page"},{"location":"priorityqueues/#Fast-priority-queues","page":"Priority queues","title":"Fast priority queues","text":"","category":"section"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"If keys are analogous to indices in some array, the key-node association can be realized by a regular array which is faster than a dictionary as used by versatile priority queues. To build a fast priority queue with keys indexing an array of dimensions dims..., call the FastPriorityQueue constructor:","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"Q = FastPriorityQueue{V}([o=TotalMin,] [T=Node{Int,V},] dims...)","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"where o::Ordering specifies the ordering of values in the priority queue, T<:AbstractNode{Int,V} is the type of the nodes depending on V the type of the values encoding the priority. Type parameter V may be omitted if the node type T is specified.","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"The keys in this kind of priority queue are the linear or Cartesian indices in an array of size dims.... For example, if dims = (3,4,5), then all the following expressions refer to the same key:","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"Q[44]\nQ[2,3,4]\nQ[CartesianIndex(2,3,4)]","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"The storage of a fast priority queue requires prod(dims...)*sizeof(Int) + n*sizeof(T) bytes with n enqueued nodes.","category":"page"},{"location":"priorityqueues/#Common-methods-for-priority-queues","page":"Priority queues","title":"Common methods for priority queues","text":"","category":"section"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"In QuikHeaps, priority queues have a common interface which is described here.","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"The first thing to do with a freshly created priority queue is to populate it. To enqueue key k with priority v in priority queue Q, all the following is equivalent:","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"Q[k] = v\npush!(Q, k => v)\nenqueue!(Q, k => v)\nenqueue!(Q, k, v)","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"Note that key k may already exists in Q; in this case, the priority associated with the key is updated and the queue reordered if necessary in, at worse, O(log(n)) operations. This is generally faster than first deleting the key and then enqueuing the key with the new priority.","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"To extract the node of highest priority out of the queue Q and get its key k and, possibly, its priority v, call one of:","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"k = dequeue!(Q)\nk, v = pop!(Q)","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"Methods dequeue_pair! and dequeue_node! also extract the root node out of a priority queue and return it as a Pair or as as a node of the type used by the queue.","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"To just examine the node of highest priority, call one of:","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"k, v = peek(Q)\nk, v = first(Q)","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"Like the dequeue! method, the peek method may also be called with a type argument.","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"A priority queue Q behaves like a dictionary:","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"length(Q)         # yields number of nodes\nisempty(Q)        # yields whether priority queue is empty\nempty!(Q)         # empties priority queue\nkeytype(Q)        # yields key type `K`\nvaltype(Q)        # yields value type `V`\nQ[v]              # yields the value of key `k`\nget(Q, k, def)    # query value at key, with default\nQ[k] = v          # set value `v` of key `k`\npush!(Q, k => v)  # idem.\nhaskey(Q, k)      # yields whether key `k` exists\ndelete!(Q, k)     # delete node at key `k`","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"Note that the syntax Q[k] throws an exception if key k does not exists in Q.","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"Finally, there are different ways to iterate on the (unordered) contents of a priority queue Q:","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"keys(Q)                  # yields iterator over keys\nvals(Q)                  # yields iterator over values\nfor (k,v) in Q; ...; end # loop over key-value pairs","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"Note that these iterators yield nodes in their storage order which is not necessarily that of their priority. The order is however the same for these iterators.","category":"page"},{"location":"priorityqueues/#Priority-order","page":"Priority queues","title":"Priority order","text":"","category":"section"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"How are ordered the nodes is completely customizable by specializing the QuickHeaps.lt function with the following signature:","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"QuickHeaps.lt(o::OrderingType, x::T, y::T) where {T<:NodeType}","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"which shall yield whether node x has (strictly) higher priority than node y in the queue and where OrderingType and NodeType <: [QuickHeaps.AbstractNode](@ref) are the respective types of the ordering and of the nodes of the priority queue.","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"For the default node type, QuickHeaps.Node{K,V}, the implementation is:","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"QuickHeaps.lt(o::Ordering, x::T, y::T) where {T<:QuickHeaps.Node} =\n    Base.lt(o, QuickHeaps.get_val(x), QuickHeaps.get_val(y))","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"where QuickHeaps.get_val(x) yields the value of node x. In other words, nodes are sorted by their value according to ordering o.","category":"page"},{"location":"install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"The easiest way to install QuickHeaps is to use Julia's package manager:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"using Pkg\npkg\"add QuickHeaps\"","category":"page"},{"location":"customize/#Customize-ordering","page":"-","title":"Customize ordering","text":"","category":"section"},{"location":"customize/","page":"-","title":"-","text":"If the ordering rules provided by QuickHeaps are not suitable for your needs, you may customize how to order the values in binary heaps of in priority queues. For maximal flexibility, you may also customize how nodes (not values) are ordered in priority queues. This is possible because sorting of values and nodes in QuickHeaps calls QuickHeaps.lt(o::SomeOrder, x::T, y::T) to decide whether x < y holds according to o. For priority queues, x and y are the nodes stored by the priority queue and the default behavior is to compare the node values. For values (in binary heaps or in priority queues), the default is that QuickHeaps.lt calls Base.Order.lt. These rules are implemented by the following few lines in QuickHeaps:","category":"page"},{"location":"customize/","page":"-","title":"-","text":"QuickHeaps.lt(o::Base.Order.Ordering, x::T, y::T) where {T<:QuickHeaps.AbstractNode} =\n    QuickHeaps.lt(o, QuickHeaps.get_val(x), QuickHeaps.get_val(y))\n\nQuickHeaps.lt(o::Base.Order.Ordering, x::T, y::T) where {T} =\n    Base.Order.lt(o, x, y)","category":"page"},{"location":"customize/","page":"-","title":"-","text":"In the methods implemented by the QuickHeaps package, calls to Base.Order.lt and QuickHeaps.lt are always for elements of the same type. Hence the restriction that x and y are both of the same type T above. This is something to remember when customizing the behavior of QuickHeaps.lt.","category":"page"},{"location":"customize/#Customize-ordering-of-values","page":"-","title":"Customize ordering of values","text":"","category":"section"},{"location":"customize/","page":"-","title":"-","text":"For binary heaps and priority queues with values of type ValType, you may create your own ordering type, say MyOrder, inheriting from Base.Order.Ordering and specialize Base.Order.lt(o::MyOrder, x::ValType, y::ValType) to yield whether x < y according to o and for values x and y. Typically:","category":"page"},{"location":"customize/","page":"-","title":"-","text":"struct MyOrder <: Base.Order.Ordering end\nBase.Order.lt(o::MyOrder, x::ValType, y::ValType) = ... # true or false","category":"page"},{"location":"customize/","page":"-","title":"-","text":"If you do not want to specialize Base.Order.lt, you may replace this function by QuickHeaps.lt.","category":"page"},{"location":"customize/","page":"-","title":"-","text":"As an example, let us customize the ordering of floating-point values so that NaN are considered as the largest possible values:","category":"page"},{"location":"customize/","page":"-","title":"-","text":"struct FloatMin <: Base.Order.Ordering end\nBase.Order.lt(o::FloatMin, x::T, y::T) where {T<:AbstractFloat} =\n    (! isnan(x)) & (isnan(y) | (x < y))","category":"page"},{"location":"customize/","page":"-","title":"-","text":"The result of Base.Order.lt(FloatMin(), x, y) is the same as isless(x, y) but the above implementation of Base.Order.lt is faster than isless because it uses non-branching bitwise operators instead of logical ones (then, parentheses are needed owing to the precedence rules of bitwise operators). This is an example of the benefits of customizing the ordering of values. Since this amounts to specializing Base.Order.lt, the same optimization is applicable to other sorting algorithms in Julia.","category":"page"},{"location":"customize/#Customize-ordering-of-nodes","page":"-","title":"Customize ordering of nodes","text":"","category":"section"},{"location":"customize/","page":"-","title":"-","text":"As an additional flexibility, for priority queues with nodes of type NodeType and ordering of type OrderType, you may also specialize QuickHeaps.lt(o::OrderType, x::NodeType, y::NodeType) to order the nodes with a specific rule that may account for the keys of the nodes (not just their values). However to avoid type-piracy, at least one of NodeType or OrderType must be foreign to QuickHeaps.","category":"page"},{"location":"customize/","page":"-","title":"-","text":"If you opt on customizing on the ordering type and do not use a specific node type, you must write something like:","category":"page"},{"location":"customize/","page":"-","title":"-","text":"struct MyOrder <: Base.Order.Ordering end # custom ordering type\nfunction QuickHeaps.lt(o::MyOrder, x::T, y::T) where {T<:QuickHeaps.Node}\n    # Below, `QuickHeaps.get_key` and/or `QuickHeaps.get_val` may be called to retrieve\n    # the key or value of nodes `x` and `y`.\n    true_or_false = ...\n    return true_or_false\nend","category":"page"},{"location":"customize/","page":"-","title":"-","text":"The restriction T <: QuickHeaps.Node above is because, by default in QuickHeaps, priority queues store their nodes as instances of QuickHeaps.Node{K,V}. As noted in the above comment QuickHeaps.get_key and/or QuickHeaps.get_val may be called to retrieve # the key or value of nodes x and y.","category":"page"},{"location":"customize/","page":"-","title":"-","text":"If you opt for using your own node type, you may or not use an existing ordering type but you must implement a new node type following the guidelines in the Node types section of the manual.","category":"page"},{"location":"nodes/#Nodes-types","page":"Nodes types","title":"Nodes types","text":"","category":"section"},{"location":"nodes/","page":"Nodes types","title":"Nodes types","text":"Nodes in priority queues provided by QuickHeaps have super-type:","category":"page"},{"location":"nodes/","page":"Nodes types","title":"Nodes types","text":"QuickHeaps.AbstractNode{K,V}","category":"page"},{"location":"nodes/","page":"Nodes types","title":"Nodes types","text":"with K and V the respective types of the key and of the value of the node. In principle, priority of a node is based on its value, but this may be changed by using custom node and/or ordering types.","category":"page"},{"location":"nodes/","page":"Nodes types","title":"Nodes types","text":"Having a specific node type different than, say, Pair{K,V} is to allow customizing how the nodes are compared for ordering by specializing QuickHeaps.lt without type-piracy.","category":"page"},{"location":"nodes/","page":"Nodes types","title":"Nodes types","text":"A node x can be iterated and converted into a pair or a 2-tuple of its key and its value val and conversely:","category":"page"},{"location":"nodes/","page":"Nodes types","title":"Nodes types","text":"x = QuickHeaps.Node(key, val)   # builds a node\nx = QuickHeaps.Node((key, val)) # idem\nx = QuickHeaps.Node(key => val) # idem\nkey, val = x                    # extract key and value of a node\nPair(x)                         # yields key=>val\nTuple(x)                        # yields (key,val)","category":"page"},{"location":"nodes/","page":"Nodes types","title":"Nodes types","text":"The non-exported methods QuickHeaps.get_key(x) and QuickHeaps.get_val(x) methods respectively retrieve the key and the value of a node. These two methods may be specialized for a given sub-type of QuickHeaps.AbstractNode. For example, a key-only node type can be fully implemented by:","category":"page"},{"location":"nodes/","page":"Nodes types","title":"Nodes types","text":"struct KeyOnlyNode{K} <: QuickHeaps.AbstractNode{K,Nothing}\n    key::K\nend\nQuickHeaps.get_key(x::KeyOnlyNode) = getfield(x, :key)\nQuickHeaps.get_val(x::KeyOnlyNode) = nothing\nKeyOnlyNode(key::K, ::Nothing) where {K} = KeyOnlyNode{K}(key)\nKeyOnlyNode((key, _)::Union{Tuple{K,V},Pair{K,V}}) where {K,V<:Nothing} = KeyOnlyNode{K}(key)","category":"page"},{"location":"nodes/","page":"Nodes types","title":"Nodes types","text":"To provide your own ordering rules, you may specialize QuickHeaps.lt which otherwise defaults to:","category":"page"},{"location":"nodes/","page":"Nodes types","title":"Nodes types","text":"QuickHeaps.lt(o::Ordering, x::QuickHeaps.AbstractNode, y::QuickHeaps.AbstractNode) =\n    Base.Order.lt(o, QuickHeaps.get_val(x), QuickHeaps.get_val(y))","category":"page"},{"location":"binaryheaps/#Binary-heaps","page":"Binary heaps","title":"Binary heaps","text":"","category":"section"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"Binary heaps dynamically store values in a tree structure built according to a given ordering of these values. Thanks to this structure, a number of operations can be efficiently implemented. For a binary heap of n values, pushing a new value, extracting the first value out of the heap, deleting a value, and replacing a value all have a complexity of O(log(n)) at worst. Just getting the first value without extracting it out of the heap is an O(1) operation. Here, values means objects of any type that implement an ordering rule, not necessarily numeric values. Depending on the ordering chosen for the heap, the first value (also called the root value) may be the least or the greatest one.","category":"page"},{"location":"binaryheaps/#Basic-usage","page":"Binary heaps","title":"Basic usage","text":"","category":"section"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"In QuickHeaps, a binary heap is created by the BinaryHeap constructor:","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"h = BinaryHeap{T}(o = TotalMin)","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"where T is the type of the values stored by the heap and o::Ordering is the ordering rule for sorting values. The default TotalMin ordering yields a min-heap whose root entry is the smallest one. With o = TotalMax, a max-heap is created. A min-heap (resp. a max-heap) sorts its values in increasing (resp. decreasing) order, followed by NaN then missing values.","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"For floating-point values, orderings FastMin or FastMax may be used, respectively, instead of TotalMin or TotalMax for faster sorting of the heap. However, FastMin and FastMax do not define the order of NaN values and fail on missing values. If your data may contains NaN or missing values, use TotalMin or TotalMax instead of FastMin or FastMax.","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"A vector vals storing the initial values of the binary heap can be specified:","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"h = BinaryHeap{T}(vals, o = TotalMin)","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"to create a binary heap starting with the values in vals. Type parameter T can be omitted to assume T=eltype(vals). The initial values need not be ordered, the BinaryHeap constructor automatically takes care of that. If vals is a Vector instance with elements of type T, the binary-heap will be directly built into vals. Call BinaryHeap(copy(vals)) to create a binary heap with its own storage.","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"A binary heap h can be used as an ordered queue of values:","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"pop!(h)     # yields the root value and discard it from the heap\npush!(h, x) # pushes value x in heap h","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"The root value is the first one according to the ordering of the heap. To examine the root value without discarding it from the heap, call either of:","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"peek(h)\nfirst(h)\nh[1]","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"A binary heap h behaves like an abstract vector (with 1-based linear indices), in particular:","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"length(h)   # yields the number of values in heap h\nh[i]        # yields the i-th value of heap h\nh[i] = x    # sets the i-th value of heap h and heapify h","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"Note that h[1] is the value of the root entry of the heap h (the least heap values for a min-heap, the greatest heap value for a max-heap) and that setting a value in the heap may trigger reordering of the values stored by the heap to maintain the binary heap structure. In particular, after doing h[i] = x, do not assume that h[i] yields x because the heap h is automatically (and efficiently) re-ordered so as to maintain its heap structure.","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"To delete the i-th value from the heap h, call:","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"delete!(h, i)","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"Call empty!(h) to delete all the values of the binary heap h and isempty(h) to query whether h is empty.","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"note: Note\nOperations that modify the heap, like deletion by delete!(h,i), insertion by h[i] = x, pushing by push!(h,x), and extracting by pop!(h) are of numerical complexity O(1) in the best case, O(log(n)) in the worst case, with n = length(h) the number of values in the heap h. Query a given value with peek(h), first(h), or h[i] is always of complexity O(1).","category":"page"},{"location":"binaryheaps/#Advanced-usage","page":"Binary heaps","title":"Advanced usage","text":"","category":"section"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"Instances of BinaryHeap store their values in a Julia vector whose length is always equal to the number of stored values. Slightly faster binary heaps are created by the FastBinaryHeap constructor. Such binary heaps never automatically reduce the size of the array backing the storage of their values (even though the size is automatically augmented as needed). You may call resize!(h) to explicitly reduce the storage to its minimum.","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"A hint about the anticipated size n of a heap h (of any kind) can be set by:","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"sizehint!(h, n)","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"which yields h.","category":"page"},{"location":"binaryheaps/#Customize-binary-heaps","page":"Binary heaps","title":"Customize binary heaps","text":"","category":"section"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"The behavior of the binary heap types provided by QuickHeaps can be tweaked by using a particular instance of the ordering o::Ordering and by specializing the Base.lt method called as Base.lt(o,x,y) to decide whether value x occurs before value y according to ordering o. In the implementation of binary heaps by the QuickHeaps package, x and y are always both of type T, the type of the values stored by the heap.","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"If this is not sufficient, a custom binary heap type may be created that inherits from AbstractBinaryHeap{T,O} with T the type of the values stored by the heap and O the type of the ordering. Assuming the array backing the storage of the values in the custom heap type has 1-based linear indexing, it is sufficient to specialize the following methods for an instance h of the custom heap type, say CustomBinaryHeap:","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"Base.length(h::CustomBinaryHeap) yields the number of values in h;\nBase.empty!(h::CustomBinaryHeap) delete all values in h;\nQuickHeaps.storage(h::CustomBinaryHeap) yields the array backing the storage of values;\nQuickHeaps.ordering(h::CustomBinaryHeap)] yields the ordering of the values;\nQuickHeaps.unsafe_grow!(h::CustomBinaryHeap, n::Integer) to grow the size of the object backing the storage of h to have n elements;\nQuickHeaps.unsafe_shrink!(h::CustomBinaryHeap, n::Integer) to shrink the size of the object backing the storage of h to have n elements;","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"to have a fully functional custom binary heap type.","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"By default, Base.resize!(h) does nothing (except returning its argument) for any instance h of a type that inherits from AbstractBinaryHeap; but this method may also be specialized.","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"The QuickHeaps package provides a number of methods (some unexported) that may be useful for implementing new binary heap types:","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"QuickHeaps.heapify\nQuickHeaps.heapify!\nQuickHeaps.isheap\nQuickHeaps.heapify_down!\nQuickHeaps.heapify_up!\nQuickHeaps.unsafe_heapify_down!\nQuickHeaps.unsafe_heapify_up!","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"Note that the heapify, heapify!, and isheap functions which are exported by the QuickHeaps package have the same behavior but are different than those in the DataStructures package. If you are using both packages, you'll have to explicitly prefix these methods by the package module.","category":"page"},{"location":"binaryheaps/#Simple-priority-queues","page":"Binary heaps","title":"Simple priority queues","text":"","category":"section"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"A binary heap can be used to implement a simple priority queue with keys of type K and values of type V as follows:","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"struct Node{K,V}\n   key::K\n   val::V\nend\nBase.lt(o::Base.Ordering, a::T, b::T) where {T<:Node} = lt(o, a.val, b.val)\nQ = FastBinaryHeap{Node}()","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"This simple priority queue is a binary heap (a min-heap in that case) of nodes storing key-value pairs which as sorted according to their values. The same Node structure as the one defined above and with the same specialization of Base.lt is provided (but not exported) by QuickHeaps, so a simplified version of the above example is:","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"using QuickHeaps: Node\nQ = FastBinaryHeap{Node}()","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"Such a priority queue is faster than DataStructures.PriorityQueue but it provides no means to re-queue a node nor to ensure that keys are unique. An auxiliary array, a dictionary, or a set can be used for that, this is implemented by QuickHeaps.PriorityQueue and QuickHeaps.FastPriorityQueue which are more flexible and offer more capabilities than the simple implementation in the above example.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"QuickHeaps is a Julia package providing versatile binary heaps and priority queues. These data structures are more flexible and may be quite significantly faster than those provided by DataStructures.","category":"page"},{"location":"#Table-of-contents","page":"Introduction","title":"Table of contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\"install.md\", \"binaryheaps.md\", \"priorityqueues.md\",\n    \"nodes.md\", \"library.md\"]","category":"page"},{"location":"#Index-of-types-and-methods","page":"Introduction","title":"Index of types and methods","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"}]
}
