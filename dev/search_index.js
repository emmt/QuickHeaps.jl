var documenterSearchIndex = {"docs":
[{"location":"library/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"library/","page":"Reference","title":"Reference","text":"The following reproduces the in-lined documentation about types and methods of the QuickHeaps package. This documentation is also available from the REPL by typing ? followed by the name of a method or a type.","category":"page"},{"location":"library/#Binary-Heaps","page":"Reference","title":"Binary Heaps","text":"","category":"section"},{"location":"library/","page":"Reference","title":"Reference","text":"QuickHeaps.AbstractBinaryHeap\nQuickHeaps.BinaryHeap\nQuickHeaps.FastBinaryHeap\nQuickHeaps.heapify\nQuickHeaps.heapify!\nQuickHeaps.heapify_down!\nQuickHeaps.heapify_up!\nQuickHeaps.isheap\nQuickHeaps.unsafe_heapify_down!\nQuickHeaps.unsafe_heapify_up!\nQuickHeaps.unsafe_grow!\nQuickHeaps.unsafe_shrink!","category":"page"},{"location":"library/#QuickHeaps.AbstractBinaryHeap","page":"Reference","title":"QuickHeaps.AbstractBinaryHeap","text":"QuickHeaps.AbstractBinaryHeap{T,O}\n\nis the super-type of binary heaps in QuickHeaps whose values have type T and whose ordering has type O.\n\nThe following methods are available for a binary heap h (those which modify the heap contents re-order heap values as needed to maintain the heap structure):\n\npop!(h)        # deletes and returns root value of heap h\npush!(h, x)    # pushes value x in heap h\nempty!(h)      # empties heap h\nisempty(h)     # yields whether heap h is empty\ndelete!(h, i)  # deletes i-th value from heap h\npeek(h)        # yields root value of heap h without deleting it\nfirst(h)       # idem\nsetroot!(h, x) # same as h[1] = x, replaces root value of heap h by x\n\nA binary heap h behaves like an abstract vector (with 1-based linear indices), in particular:\n\nlength(h)   # the number of values in heap h\nh[i]        # the i-th value of heap h\nh[i] = x    # set the i-th value of heap h and heapify h\n\nNote that h[1] is the root value of the heap h and that setting a value in the heap may trigger reordering of the values to maintain the binary heap structure. In other words, after doing h[i] = x, do not assume that h[i] yields x.\n\nOperations that modify the heap, like deletion by delete!(h,i), insertion by h[i] = x, pushing by push!(h,x), and extracting by pop!(h) are of complexity O(1) in the best case, O(log(n)) in the worst case, with n = length(h) the number of values in the heap h. Retrieving a given value with peek(h), first(h), or h[i] is always of complexity O(1).\n\nCall Base.Order.Ordering(h) to retrieve the ordering object o for the binary heap h.\n\n\n\n\n\n","category":"type"},{"location":"library/#QuickHeaps.BinaryHeap","page":"Reference","title":"QuickHeaps.BinaryHeap","text":"h = BinaryHeap{T}([o::Base.Order.Ordering = TotalMin,][ vals::AbstractVector])\n\nBuild an empty binary heap whose values have type T and with ordering specified by o.\n\nThe method Base.Order.lt(o,x::T,y::T) is called to determine the order of values x and y in the heap. The default ordering, TotalMin, yields a min-heap object; with TotalMax ordering, a max-heap object is returned.\n\nAn optional vector vals storing the initial values of the binary heap can be specified. These values in vals need not be ordered, the BinaryHeap constructor automatically takes care of that. If vals is a Vector{T} instance, the binary-heap will be directly built into vals. Call BinaryHeap(copy(vals)) to create a binary heap with its own storage.\n\nArguments o and vals may be specified in any order.\n\nMethod sizehint!(h,n) may be called to anticipate that the heap may contains n values.\n\n\n\n\n\n","category":"type"},{"location":"library/#QuickHeaps.FastBinaryHeap","page":"Reference","title":"QuickHeaps.FastBinaryHeap","text":"h = FastBinaryHeap{T}([o::Base.Order.Ordering = TotalMin,][ vals::AbstractVector])\n\nBuild a fast binary heap. Compared to BinaryHeap{T}(...), the array backing the storage of the heap values is never automatically reduced to improve performances in some cases. You may call resize!(h) to explicitly reduce the storage of fast binary-heap h to its minimum.\n\n\n\n\n\n","category":"type"},{"location":"library/#QuickHeaps.heapify","page":"Reference","title":"QuickHeaps.heapify","text":"heapify([o=TotalMin,] A, n=length(A))\n\nyields an array with the n first values of array A stored in a binary heap structure of ordering specified by o. The storage of the returned heap is a different array than A. Arguments may be specified in any order.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.heapify!","page":"Reference","title":"QuickHeaps.heapify!","text":"heapify!(h) -> h\n\nreorders the values in the binary heap h in-place. This method should be called to initialize the heap or to re-order the heap if its contents have been modified by other methods than pop! or push!.\n\nThe method can be called at a lower level to heapify (part of) an array storing the heap values:\n\nheapify!([o=TotalMin,] A, n=length(A)) -> A\n\nreorders the n first elements of array A in-place to form a binary heap according to the ordering specified by o. The array A must have 1-based linear indexing. Arguments may be specified in any order.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.heapify_down!","page":"Reference","title":"QuickHeaps.heapify_down!","text":"QuickHeaps.heapify_down!(o, A, i, x=A[i], n=lengh(A)) -> A\n\nstores the value x in the i-th entry of the binary heap built into the n first elements of array A with ordering o and, if needed, moves down the inserted value to maintain the binary heap structure.\n\nThis method is called to heapify an array in order to initialize or rebuild the heap structure or to replace the value of the root value of the heap and update the heap structure.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.heapify_up!","page":"Reference","title":"QuickHeaps.heapify_up!","text":"QuickHeaps.heapify_up!(o, A, i, x=A[i]) -> A\n\nstores the value x in the i-th entry of the binary heap built into the i first elements of array A with ordering o and, if needed, moves up the value to maintain the heap structure.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.isheap","page":"Reference","title":"QuickHeaps.isheap","text":"isheap([o=TotalMin,], A, n=length(A))\n\nyields whether the n first elements of array A have a binary heap structure ordered as specified by o. Arguments may be specified in any order.\n\nisheap(obj; check=false)\n\nyields whether object obj is a binary heap. If keyword check is true, the internal structure of obj is checked; otherwise, the type of obj is trusted to determine whether it is a binary heap.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.unsafe_heapify_down!","page":"Reference","title":"QuickHeaps.unsafe_heapify_down!","text":"QuickHeaps.unsafe_heapify_down!(o, A, i, x=A[i], n=lengh(A))\n\nThis method is a fast but unsafe version of QuickHeaps.heapify_down! which assumes that all arguments are correct, that is A implements 1-based linear indexing, 0 ≤ n ≤ lengh(A), and 1 ≤ i ≤ n.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.unsafe_heapify_up!","page":"Reference","title":"QuickHeaps.unsafe_heapify_up!","text":"QuickHeaps.unsafe_heapify_up!(o, A, i, x=A[i])\n\nThis methods is a fast but unsafe version of QuickHeaps.heapify_up! which assumes that all arguments are correct, that is A implements 1-based linear indexing and 1 ≤ i ≤ length(A).\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.unsafe_grow!","page":"Reference","title":"QuickHeaps.unsafe_grow!","text":"QuickHeaps.unsafe_grow!(h, n) -> A\n\ngrows the size of the binary heap h to be n and returns the array A backing the storage of the values. This method is unsafe because it does not check its arguments and because it breaks the binary heap structure of the array of values.\n\nThis method is called by push! to grow the size of the heap and shall be specialized for any concrete sub-types of QuickHeaps.AbstractBinaryHeap.\n\n\n\n\n\nQuickHeaps.unsafe_grow!(pq, n) -> pq\n\ngrows the size of the binary heap backing the storage of the entries of the priority queue pq to be n and returns the priority queue object.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.unsafe_shrink!","page":"Reference","title":"QuickHeaps.unsafe_shrink!","text":"QuickHeaps.unsafe_shrink!(h, n)\n\nshrinks the size of the binary heap h to be n. This method is unsafe because it does not check its arguments.\n\nThis method is called by delete! to eventually reduce the size of the heap and shall be specialized for any concrete sub-type of QuickHeaps.AbstractBinaryHeap.\n\n\n\n\n\nQuickHeaps.unsafe_shrink!(pq, n)\n\nshrinks the size of the binary heap backing the storage of the entries of the priority queue pq to be n.\n\n\n\n\n\n","category":"function"},{"location":"library/#Priority-Queues","page":"Reference","title":"Priority Queues","text":"","category":"section"},{"location":"library/","page":"Reference","title":"Reference","text":"QuickHeaps.AbstractPriorityQueue\nQuickHeaps.PriorityQueue\nQuickHeaps.FastPriorityQueue\ndequeue!(::QuickHeaps.AbstractPriorityQueue)\ndequeue_pair!\nenqueue!(::QuickHeaps.AbstractPriorityQueue, ::Any, ::Any)","category":"page"},{"location":"library/#QuickHeaps.AbstractPriorityQueue","page":"Reference","title":"QuickHeaps.AbstractPriorityQueue","text":"QuickHeaps.AbstractPriorityQueue{K,V,O}\n\nis the super type of priority queues with ordering of type O<:Base.Order.Ordering and storing keys of type K associated priority values of type V.\n\nPackage QuickHeaps provides two concrete types of priority queues: PriorityQueue for any kind of keys and FastPriorityQueue for which keys are analogous to array indices.\n\nPriority queues behave like dictionaries with the additional feature of automatically maintaining an ordered structure according to the priority queue ordering and the entry values. For a priority queue pq, retrieving the root entry, that is the pair key => val of highest priority, without removing it costs O(1) and is done by:\n\npeek(pq) -> (key => val)\n\nRetrieving the value of an entry given its key has also an O(1) complexity and is done by one of:\n\npq[key...] -> val\ngetindex(pq, key...) -> val\nget(pq, key, def) -> val_at_key_or_def\n\nChanging the content of the priority queue has a complexity of O(log(n)) with n = length(pq) the number of queued entries. This includes removing the entry at key by:\n\ndelete!(pq, key) -> pq\n\nremoving the root entry by:\n\npop!(pq)          # -> root entry as a `key=>val` pair\ndequeue!(pq)      # -> key of root entry\ndequeue_pair!(pq) # -> root entry as a `key=>val` pair\n\nor setting/changing an entry with a given key and value val by one of:\n\npq[key] = val\nenqueue!(pq, key => val)\npush!(pq, key => val)\n\nCall Base.Order.Ordering(pq) to retrieve the ordering object o for the priority queue pq.\n\n\n\n\n\n","category":"type"},{"location":"library/#QuickHeaps.PriorityQueue","page":"Reference","title":"QuickHeaps.PriorityQueue","text":"PriorityQueue{K,V}(o=TotalMin)\n\nyields a priority queue for keys of type K and priority values of type V. Optional argument o::Ordering specifies the ordering of values.\n\nIf keys are analogous to array indices (linear or Cartesian), FastPriorityQueue may provide a faster alternative.\n\n\n\n\n\n","category":"type"},{"location":"library/#QuickHeaps.FastPriorityQueue","page":"Reference","title":"QuickHeaps.FastPriorityQueue","text":"FastPriorityQueue{V}(o=TotalMin, dims...)\n\nyields a priority queue for keys analogous of indices in an array of size dims... and priority values of type V. Optional argument o::Ordering specifies the ordering of values. The keys are stored as linear indices of type Int.\n\nSee PriorityQueue if keys cannot be assumed to be array indices.\n\n\n\n\n\n","category":"type"},{"location":"library/#DataStructures.dequeue!-Tuple{AbstractPriorityQueue}","page":"Reference","title":"DataStructures.dequeue!","text":"dequeue!(pq) -> key\n\nRemove the root entry from the priority queue pq and return its key.\n\nYou may call dequeue_pair!(pq) to dequeue the root entry as a key-value pair.\n\n\n\n\n\n","category":"method"},{"location":"library/#DataStructures.dequeue_pair!","page":"Reference","title":"DataStructures.dequeue_pair!","text":"dequeue_pair!(pq) -> (key => val)\n\nRemove the root entry from the priority queue pq and return it as a key-value pair. This is the same as pop!(pq).\n\nAlso see dequeue!.\n\n\n\n\n\n","category":"function"},{"location":"library/#DataStructures.enqueue!-Tuple{AbstractPriorityQueue, Any, Any}","page":"Reference","title":"DataStructures.enqueue!","text":"pq[key...] = val\nsetindex!(pq, val, key...) -> pq\nenqueue!(pq, key, val) -> pq\nenqueue!(pq, key => val) -> pq\npush!(pq, key => val) -> pq\n\nSet the value val stored by the priority queue pq at index key automatically maintaining the partial ordering of pq.\n\n\n\n\n\n","category":"method"},{"location":"library/#Orderings","page":"Reference","title":"Orderings","text":"","category":"section"},{"location":"library/","page":"Reference","title":"Reference","text":"QuickHeaps.FastMin\nQuickHeaps.FastMax\nQuickHeaps.TotalMin\nQuickHeaps.TotalMax","category":"page"},{"location":"library/#QuickHeaps.FastMin","page":"Reference","title":"QuickHeaps.FastMin","text":"QuickHeaps.FastMinOrdering <: Base.Order.Ordering\nconst FastMin = QuickHeaps.FastMinOrdering()\n\nSingleton for min ordering. This ordering is faster than TotalMin but leaves indefinite the order of NaN values.\n\nQuickHeaps.FastMinOrdering is the type of FastMin.\n\nAlso see FastMax.\n\n\n\n\n\n","category":"constant"},{"location":"library/#QuickHeaps.FastMax","page":"Reference","title":"QuickHeaps.FastMax","text":"FastMax\n\nSingleton for max ordering. This ordering is faster than TotalMax but leaves indefinite the order of NaN values.\n\nQuickHeaps.FastMaxOrdering is an alias to the type of FastMax.\n\nAlso see FastMin.\n\n\n\n\n\n","category":"constant"},{"location":"library/#QuickHeaps.TotalMin","page":"Reference","title":"QuickHeaps.TotalMin","text":"TotalMin\n\nSingleton for total min ordering considering NaN's as greater than any other floating-point value, and missing to be greater than anything else. With this ordering, values are sorted in ascending order, followed by NaN then missing values.\n\nTotalMin is similar to the default ordering in most Julia algorithms and which is implemented by isless. However, for arrays of floating-point values with 50% of NaN's, TotalMin is nearly as fast as (19%) using < and is almost twice faster (82%) than isless. This speed-up is obtained by using non-branching bitwise operators instead of logical operators.\n\nQuickHeaps.TotalMinOrdering is the type of TotalMin.\n\nAlso see TotalMax.\n\n\n\n\n\n","category":"constant"},{"location":"library/#QuickHeaps.TotalMax","page":"Reference","title":"QuickHeaps.TotalMax","text":"TotalMax\n\nSingleton for total max ordering. With this ordering, values are sorted in decreasing order, followed by NaN then missing values.\n\nQuickHeaps.TotalMaxOrdering is the type of TotalMax.\n\nnote: Note\nTotalMax and reverse(TotalMin) both sort regular values in decreasing order but the latter puts missing then NaN values first.\n\nAlso see TotalMin.\n\n\n\n\n\n","category":"constant"},{"location":"library/#Miscellaneous","page":"Reference","title":"Miscellaneous","text":"","category":"section"},{"location":"library/","page":"Reference","title":"Reference","text":"The following non-exported methods may be needed for implementing new types of binary heap or of priority queue. End-users probably not have to worry about these.","category":"page"},{"location":"library/","page":"Reference","title":"Reference","text":"QuickHeaps.has_bad_values\nQuickHeaps.heap_index\nQuickHeaps.storage\nQuickHeaps.setroot!","category":"page"},{"location":"library/#QuickHeaps.has_bad_values","page":"Reference","title":"QuickHeaps.has_bad_values","text":"QuickHeaps.has_bad_values(A[, isbad])\n\nyields whether array A has bad values according to predicate isbad. For arrays with floating-point values, isbad default to isnan if unspecified. For integer-valued arrays, this function always returns false if isnan is unspecified.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.heap_index","page":"Reference","title":"QuickHeaps.heap_index","text":"QuickHeaps.heap_index(pq, key) -> i::Int\n\nReturn the index i corresponding to key in the binary heap backing the storage of the entries of the priority queue pq. If the key is not in priority queue, i = 0 is returned, otherwise i ∈ 1:n with n = length(pq) is returned.\n\nThe heap_index method is used to implement haskey, get, and delete! methods for priority queues. The heap_index method shall be specialized for any concrete sub-types of QuickHeaps.AbstractPriorityQueue.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.storage","page":"Reference","title":"QuickHeaps.storage","text":"QuickHeaps.storage(h)\n\nyields the array backing the storage of the values in the binary heap h.\n\nThis method may be specialized for custom binary heap types.\n\n\n\n\n\n","category":"function"},{"location":"library/#QuickHeaps.setroot!","page":"Reference","title":"QuickHeaps.setroot!","text":"setroot!(h, x) -> h\n\nreplaces the value of the root note in heap h by x. This is similar to h[1] = x but a bit faster.\n\n\n\n\n\n","category":"function"},{"location":"priorityqueues/#Priority-queues","page":"Priority queues","title":"Priority queues","text":"","category":"section"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"Priority queues are partially ordered dynamic lists whose entries are key-value pairs. Priority queues are designed so that updating the list of stored entries while maintaining the ordering and retrieving or extracting the entry of highest priority are efficient operations.","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"Priority queues provided by QuikHeaps are similar to dictionaries (or to arrays) with the additional feature of maintaining an ordered structure so that getting the entry of highest priority costs O(1) operations while changing the priority of an entry or pushing an entry only costs O(log(n)) operations with n the number of entries in the queue.","category":"page"},{"location":"priorityqueues/#Building-priority-queues","page":"Priority queues","title":"Building priority queues","text":"","category":"section"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"In QuikHeaps, priority queues combine a binary heap to store the partially sorted list of entries and another structure to associate keys and entries. There are two possibilities depending on the kind of keys.","category":"page"},{"location":"priorityqueues/#Versatile-priority-queues","page":"Priority queues","title":"Versatile priority queues","text":"","category":"section"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"QuikHeaps provides versatile priority queues which use a dictionary to associate keys with values and thus impose no restrictions on the type of the keys. To build a versatile priority queue, call the PriorityQueue constructor:","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"Q = PriorityQueue{K,V}(o=TotalMin)","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"where type parameters K and V are the respective types of the keys and of the values while optional parameter o::Ordering specifies the ordering for deciding the priority of values.","category":"page"},{"location":"priorityqueues/#Fast-priority-queues","page":"Priority queues","title":"Fast priority queues","text":"","category":"section"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"If keys are analogous to indices in some array, the key-value association can be realized by a regular array which is faster than a dictionary as used by versatile priority queues. To build a fast priority queue with keys indexing an array of dimensions dims..., call the FastPriorityQueue constructor:","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"Q = FastPriorityQueue{V}([o=TotalMin,] dims...)","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"where type parameter V is the type of the values, optional o::Ordering specifies the ordering of values in the priority queue, and arguments dims... specify the array shape.","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"The keys in this kind of priority queue are the linear or Cartesian indices in an array of size. For example, if dims = (3,4,5), then all the following expressions refer to the same key:","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"Q[44]\nQ[2,3,4]\nQ[CartesianIndex(2,3,4)]\nQ[CartesianIndex(2,3),4]","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"The keys of fast priority queues are however stored as linear indices, hence:","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"getkey(Q, 44, missing)\ngetkey(Q, CartesianIndex(2,3,4), missing)","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"would both yield 44 if this key is defined or missing otherwise.","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"For n enqueued entries, the storage of a fast priority queue requires about sizeof(Int)*(n + prod(dims...)) + n*sizeof(V) bytes.","category":"page"},{"location":"priorityqueues/#Common-methods-for-priority-queues","page":"Priority queues","title":"Common methods for priority queues","text":"","category":"section"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"In QuikHeaps, priority queues have a common interface which is described here.","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"The first thing to do with a freshly created priority queue is to populate it. To enqueue key k with priority v in priority queue Q, all the following is equivalent:","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"Q[k] = v\npush!(Q, k => v)\nenqueue!(Q, k => v)\nenqueue!(Q, k, v)","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"Note that key k may already exists in Q; in this case, the priority associated with the key is updated and the queue reordered if necessary in, at worse, O(log(n)) operations. This is generally faster than first deleting the key and then enqueuing the key with the new priority.","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"To extract the entry of highest priority out of the queue Q and get its key k and, possibly, its priority value v, call one of:","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"k = dequeue!(Q)\nk, v = pop!(Q)\nk, v = dequeue_pair!(Q)","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"Like pop!, dequeue_pair! extracts the root entry out of a priority queue and return it as a key-value Pair.","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"To just examine the entry of highest priority, call one of:","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"k, v = peek(Q)\nk, v = first(Q)","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"A priority queue Q behaves like a dictionary:","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"length(Q)              # get number of entries\nisempty(Q)             # whether priority queue is empty\nempty!(Q)              # make priority queue empty\nkeytype(Q)             # get key type `K`\nvaltype(Q)             # get value type `V`\nQ[v]                   # get the value of key `k`\nget(Q, k, def)         # query value at key, with default\ngetkey(Q, k, def)      # query key corresponding to `k` with default\nQ[k] = v               # set value `v` of key `k`\npush!(Q, k => v)       # idem.\nhaskey(Q, k)           # whether key `k` exists\ndelete!(Q, k)          # delete entry at key `k`\nBase.Order.Ordering(Q) # get order `o` of priority queue `Q`","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"Note that the syntax Q[k] throws an exception if key k does not exists in Q.","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"Finally, there are different ways to iterate on the (unordered) contents of a priority queue Q:","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"for k in keys(Q); ...; end   # loop over keys\nfor v in values(Q); ...; end # loop over values\nfor (k,v) in Q; ...; end     # loop over key-value pairs","category":"page"},{"location":"priorityqueues/","page":"Priority queues","title":"Priority queues","text":"Note that these iterators yield entries in their storage order which is not necessarily that of their priority. The order is however the same for these iterators.","category":"page"},{"location":"install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"The easiest way to install QuickHeaps is to use Julia's package manager:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"using Pkg\npkg\"add QuickHeaps\"","category":"page"},{"location":"customize/#Custom-order","page":"Custom order","title":"Custom order","text":"","category":"section"},{"location":"customize/","page":"Custom order","title":"Custom order","text":"If the ordering rules provided by QuickHeaps are not suitable for your needs, you may customize how to order the values in binary heaps or in priority queues.","category":"page"},{"location":"customize/#General-order-rules","page":"Custom order","title":"General order rules","text":"","category":"section"},{"location":"customize/","page":"Custom order","title":"Custom order","text":"In QuickHeaps, like in most Julia sorting algorithms, the order of entries is fully determined by the Base.Order.lt function with the following signature:","category":"page"},{"location":"customize/","page":"Custom order","title":"Custom order","text":"Base.Order.lt(o::OrderType, x::T, y::T) where {T<:ValueType}","category":"page"},{"location":"customize/","page":"Custom order","title":"Custom order","text":"which shall yield whether value x has (strictly) higher priority than value y and where OrderType <: Base.Order.Ordering and ValueType are the respective types of the order and of the values of the binary heap or priority queue. To implement a new specific order, the Base.Order.lt can be specialized for OrderType and/or for ValueType. Of course, this must be done while avoiding type piracy, e.g. using a foreign OrderType and/or for ValueType.","category":"page"},{"location":"customize/#Example-of-custom-order","page":"Custom order","title":"Example of custom order","text":"","category":"section"},{"location":"customize/","page":"Custom order","title":"Custom order","text":"As an example, let us customize the ordering of floating-point values so that NaN are considered as the largest possible values:","category":"page"},{"location":"customize/","page":"Custom order","title":"Custom order","text":"struct FloatMin <: Base.Order.Ordering end\nBase.Order.lt(o::FloatMin, x::T, y::T) where {T<:AbstractFloat} =\n    (! isnan(x)) & (isnan(y) | (x < y))","category":"page"},{"location":"customize/","page":"Custom order","title":"Custom order","text":"The result of Base.Order.lt(FloatMin(), x, y) is the same as isless(x, y) but the above implementation of Base.Order.lt is faster than isless because it uses non-branching bitwise operators instead of logical ones (then, parentheses are needed owing to the precedence rules of bitwise operators). This is an example of the benefits of customizing the ordering of values. Since this amounts to create a special sub-type of Base.Order.Ordering, the same optimization is applicable to other sorting algorithms in Julia. Incidentally, the above code reflects how TotalMin is implemented in the QuickHeaps package (except that  TotalMin also account for missing values).","category":"page"},{"location":"binaryheaps/#Binary-heaps","page":"Binary heaps","title":"Binary heaps","text":"","category":"section"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"Binary heaps dynamically store values in a tree structure built according to a given ordering of these values. Thanks to this structure, a number of operations can be efficiently implemented. For a binary heap of n values, pushing a new value, extracting the first value out of the heap, deleting a value, and replacing a value all have a complexity of O(log(n)) at worst. Just getting the first value without extracting it out of the heap is an O(1) operation. Here, values means objects of any type that implement an ordering rule, not necessarily numeric values. Depending on the ordering chosen for the heap, the first value (also called the root value) may be the least or the greatest one.","category":"page"},{"location":"binaryheaps/#Basic-usage","page":"Binary heaps","title":"Basic usage","text":"","category":"section"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"In QuickHeaps, a binary heap is created by the BinaryHeap constructor:","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"h = BinaryHeap{T}(o = TotalMin)","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"where T is the type of the values stored by the heap and o::Base.Order.Ordering is the ordering rule for sorting values. The default TotalMin ordering yields a min-heap whose root entry is the smallest one. With o = TotalMax, a max-heap is created. A min-heap (resp. a max-heap) sorts its values in increasing (resp. decreasing) order, followed by NaN then missing values.","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"For floating-point values, orderings FastMin or FastMax may be used, respectively, instead of TotalMin or TotalMax for (slightly) faster sorting of the heap. However, FastMin and FastMax do not define the order of NaN values and fail on missing values. If your data may contain NaN or missing values, use TotalMin or TotalMax instead of FastMin or FastMax.","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"A vector vals storing the initial values of the binary heap can be specified:","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"h = BinaryHeap{T}(vals, o = TotalMin)","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"to create a binary heap starting with the values in vals. Type parameter T can be omitted to assume T=eltype(vals). The initial values need not be ordered, the BinaryHeap constructor automatically takes care of that. If vals is a Vector instance with elements of type T, the binary-heap will be directly built into vals. Call BinaryHeap(copy(vals)) to create a binary heap with its own storage.","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"A binary heap h can be used as an ordered queue of values:","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"pop!(h)     # yields the root value and discard it from the heap\npush!(h, x) # pushes value x in heap h","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"The root value is the first one according to the ordering of the heap. To examine the root value without discarding it from the heap, call either of:","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"peek(h)\nfirst(h)\nh[1]","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"A binary heap h behaves like an abstract vector (with 1-based linear indices), in particular:","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"length(h)   # yields the number of values in heap h\nh[i]        # yields the i-th value of heap h\nh[i] = x    # replaces the i-th value of heap h and heapify h","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"Note that h[1] is the value of the root entry of the heap h (the least heap values for a min-heap, the greatest heap value for a max-heap) and that setting a value in the heap may trigger reordering of the values stored by the heap to maintain the binary heap structure. In particular, after doing h[i] = x, do not assume that h[i] yields x because the heap h is automatically (and efficiently) re-ordered so as to maintain its heap structure.","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"To delete the i-th value from the heap h, call:","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"delete!(h, i)","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"Call empty!(h) to delete all the values of the binary heap h and isempty(h) to query whether h is empty.","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"Call Base.Order.Ordering(h) to retrieve the order o of the binary heap h.","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"note: Note\nOperations that modify the heap, like deletion by delete!(h,i), insertion by h[i] = x, pushing by push!(h,x), and extracting by pop!(h) are of numerical complexity O(1) in the best case, O(log(n)) in the worst case, with n = length(h) the number of values in the heap h. Query a given value with peek(h), first(h), or h[i] is always of complexity O(1).","category":"page"},{"location":"binaryheaps/#Advanced-usage","page":"Binary heaps","title":"Advanced usage","text":"","category":"section"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"Instances of BinaryHeap store their values in a Julia vector whose length is always equal to the number of stored values. Slightly faster binary heaps are created by the FastBinaryHeap constructor. Such binary heaps never automatically reduce the size of the array backing the storage of their values (even though the size is automatically augmented as needed). You may call resize!(h) to explicitly reduce the storage to its minimum.","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"A hint about the anticipated size n of a heap h (of any kind) can be set by:","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"sizehint!(h, n)","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"which yields h.","category":"page"},{"location":"binaryheaps/#Customize-binary-heaps","page":"Binary heaps","title":"Customize binary heaps","text":"","category":"section"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"The behavior of the binary heap types provided by QuickHeaps can be tweaked by using a particular instance of the ordering o::Baae.Order.Ordering and by specializing the Base.lt method called as Base.Order.lt(o,x,y) to decide whether value x occurs before value y according to ordering o. In the implementation of binary heaps by the QuickHeaps package, x and y are always both of type T, the type of the values stored by the heap.","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"If this is not sufficient, a custom binary heap type may be created that inherits from AbstractBinaryHeap{T,O} with T the type of the values stored by the heap and O the type of the ordering. Assuming the array backing the storage of the values in the custom heap type has 1-based linear indexing, it is sufficient to specialize the following methods for an instance h of the custom heap type, say CustomBinaryHeap:","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"Base.length(h::CustomBinaryHeap) yields the number of values in h;\nBase.empty!(h::CustomBinaryHeap) delete all values in h;\nQuickHeaps.storage(h::CustomBinaryHeap) yields the array backing the storage of values;\nQuickHeaps.unsafe_grow!(h::CustomBinaryHeap, n::Integer) to grow the size of the object backing the storage of h to have n elements;\nQuickHeaps.unsafe_shrink!(h::CustomBinaryHeap, n::Integer) to shrink the size of the object backing the storage of h to have n elements;","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"to have a fully functional custom binary heap type.","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"By default, Base.resize!(h) does nothing (except returning its argument) for any instance h of a type that inherits from AbstractBinaryHeap; but this method may also be specialized.","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"The QuickHeaps package provides a number of methods (some unexported) that may be useful for implementing new binary heap types:","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"QuickHeaps.heapify\nQuickHeaps.heapify!\nQuickHeaps.isheap\nQuickHeaps.heapify_down!\nQuickHeaps.heapify_up!\nQuickHeaps.unsafe_heapify_down!\nQuickHeaps.unsafe_heapify_up!","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"Note that the heapify, heapify!, and isheap functions which are exported by the QuickHeaps package have the same behavior but are different than those in the DataStructures package. If you are using both packages, you'll have to explicitly prefix these methods by the package module.","category":"page"},{"location":"binaryheaps/#Simple-priority-queues","page":"Binary heaps","title":"Simple priority queues","text":"","category":"section"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"A binary heap can be used to implement a simple priority queue with keys of type K and values of type V as follows:","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"struct Node{K,V}\n   key::K\n   val::V\nend\nBase.Order.lt(o::Base.Order.Ordering, a::T, b::T) where {T<:Node} =\n    Base.Order.lt(o, a.val, b.val)\nQ = FastBinaryHeap{Node{K,V}}()","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"Another possibility is to use key => val pairs as entries and provide an ordering wrapper to compare against values of pairs:","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"struct ByValue{O<:Base.Order.Ordering} <: Base.Order.Ordering\n   order::O\nend\nBase.Order.lt(o::ByValue, (_,a)::Pair, (_,b)::Pair) = Base.Order.lt(o.order, a, b)\nQ = FastBinaryHeap{Pair{K,V}}(ByValue(Forward))","category":"page"},{"location":"binaryheaps/","page":"Binary heaps","title":"Binary heaps","text":"These simple priority queues are binary heaps of key-value entries sorted according to their values and indexed as a vector. This is useful if you are mainly interested in accessing the root entry. Such simple priority queues are faster than DataStructures.PriorityQueue but provide no means to access an entry by its key (Q is indexed by an integer linear index which depends on the position of the entry in the heap, hence, on its value not on its key) nor to ensure that keys are unique (an auxiliary array, dictionary, or set must be used for that). The QuickHeaps package provides more advanced priority queues which are sorted by value but indexed by key. QuickHeaps.PriorityQueue and QuickHeaps.FastPriorityQueue are concrete implementations of these priority queues.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"QuickHeaps is a Julia package providing versatile binary heaps and priority queues. These data structures are more flexible and usually faster than those provided by DataStructures.","category":"page"},{"location":"#Table-of-contents","page":"Introduction","title":"Table of contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\"install.md\", \"binaryheaps.md\", \"priorityqueues.md\", \"customize.md\", \"library.md\"]","category":"page"},{"location":"#Index-of-types-and-methods","page":"Introduction","title":"Index of types and methods","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"}]
}
